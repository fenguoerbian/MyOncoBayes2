// Generated by rstantools.  Do not edit by hand.

/*
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.26.1-4-gd72b68b7-dirty
#include <stan/model/model_header.hpp>
namespace model_blrm_exnex_namespace {
inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 
stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'string', line 795, column 2 to column 48)",
                                                      " (in 'string', line 796, column 2 to column 42)",
                                                      " (in 'string', line 798, column 2 to column 34)",
                                                      " (in 'string', line 801, column 2 to column 59)",
                                                      " (in 'string', line 803, column 2 to column 52)",
                                                      " (in 'string', line 805, column 2 to column 27)",
                                                      " (in 'string', line 806, column 2 to column 53)",
                                                      " (in 'string', line 807, column 2 to column 45)",
                                                      " (in 'string', line 815, column 2 to column 40)",
                                                      " (in 'string', line 816, column 2 to column 38)",
                                                      " (in 'string', line 817, column 2 to column 55)",
                                                      " (in 'string', line 818, column 2 to column 49)",
                                                      " (in 'string', line 824, column 4 to column 36)",
                                                      " (in 'string', line 825, column 4 to column 26)",
                                                      " (in 'string', line 823, column 9 to line 826, column 3)",
                                                      " (in 'string', line 821, column 4 to column 42)",
                                                      " (in 'string', line 822, column 4 to column 38)",
                                                      " (in 'string', line 820, column 27 to line 823, column 3)",
                                                      " (in 'string', line 820, column 2 to line 826, column 3)",
                                                      " (in 'string', line 829, column 4 to column 33)",
                                                      " (in 'string', line 831, column 6 to line 832, column 85)",
                                                      " (in 'string', line 830, column 25 to line 833, column 5)",
                                                      " (in 'string', line 830, column 4 to line 833, column 5)",
                                                      " (in 'string', line 835, column 6 to column 79)",
                                                      " (in 'string', line 834, column 4 to line 835, column 79)",
                                                      " (in 'string', line 828, column 25 to line 836, column 3)",
                                                      " (in 'string', line 828, column 2 to line 836, column 3)",
                                                      " (in 'string', line 838, column 2 to column 76)",
                                                      " (in 'string', line 839, column 2 to column 70)",
                                                      " (in 'string', line 843, column 6 to column 37)",
                                                      " (in 'string', line 842, column 4 to line 843, column 37)",
                                                      " (in 'string', line 841, column 2 to line 843, column 37)",
                                                      " (in 'string', line 930, column 2 to column 43)",
                                                      " (in 'string', line 931, column 2 to column 43)",
                                                      " (in 'string', line 932, column 2 to column 44)",
                                                      " (in 'string', line 933, column 2 to column 42)",
                                                      " (in 'string', line 934, column 2 to column 35)",
                                                      " (in 'string', line 935, column 2 to column 32)",
                                                      " (in 'string', line 936, column 2 to column 93)",
                                                      " (in 'string', line 938, column 4 to column 92)",
                                                      " (in 'string', line 940, column 4 to column 47)",
                                                      " (in 'string', line 937, column 23 to line 941, column 3)",
                                                      " (in 'string', line 937, column 2 to line 941, column 3)",
                                                      " (in 'string', line 944, column 4 to column 33)",
                                                      " (in 'string', line 945, column 4 to column 38)",
                                                      " (in 'string', line 946, column 17 to column 27)",
                                                      " (in 'string', line 946, column 4 to column 61)",
                                                      " (in 'string', line 948, column 11 to column 23)",
                                                      " (in 'string', line 948, column 4 to line 958, column 26)",
                                                      " (in 'string', line 959, column 4 to column 40)",
                                                      " (in 'string', line 960, column 11 to column 23)",
                                                      " (in 'string', line 960, column 4 to column 61)",
                                                      " (in 'string', line 961, column 4 to column 63)",
                                                      " (in 'string', line 962, column 24 to column 32)",
                                                      " (in 'string', line 962, column 4 to column 65)",
                                                      " (in 'string', line 963, column 23 to column 32)",
                                                      " (in 'string', line 963, column 4 to column 64)",
                                                      " (in 'string', line 964, column 4 to column 58)",
                                                      " (in 'string', line 967, column 6 to column 16)",
                                                      " (in 'string', line 973, column 10 to column 34)",
                                                      " (in 'string', line 972, column 15 to line 974, column 9)",
                                                      " (in 'string', line 970, column 10 to column 83)",
                                                      " (in 'string', line 971, column 10 to column 17)",
                                                      " (in 'string', line 969, column 36 to line 972, column 9)",
                                                      " (in 'string', line 969, column 8 to line 974, column 9)",
                                                      " (in 'string', line 975, column 8 to column 81)",
                                                      " (in 'string', line 968, column 27 to line 976, column 7)",
                                                      " (in 'string', line 968, column 6 to line 976, column 7)",
                                                      " (in 'string', line 966, column 4 to line 977, column 5)",
                                                      " (in 'string', line 979, column 6 to column 16)",
                                                      " (in 'string', line 985, column 10 to column 33)",
                                                      " (in 'string', line 984, column 15 to line 986, column 9)",
                                                      " (in 'string', line 982, column 10 to column 81)",
                                                      " (in 'string', line 983, column 10 to column 17)",
                                                      " (in 'string', line 981, column 37 to line 984, column 9)",
                                                      " (in 'string', line 981, column 8 to line 986, column 9)",
                                                      " (in 'string', line 987, column 8 to column 78)",
                                                      " (in 'string', line 980, column 28 to line 988, column 7)",
                                                      " (in 'string', line 980, column 6 to line 988, column 7)",
                                                      " (in 'string', line 978, column 4 to line 989, column 5)",
                                                      " (in 'string', line 943, column 25 to line 990, column 3)",
                                                      " (in 'string', line 943, column 2 to line 990, column 3)",
                                                      " (in 'string', line 859, column 13 to column 23)",
                                                      " (in 'string', line 859, column 6 to column 33)",
                                                      " (in 'string', line 863, column 8 to column 37)",
                                                      " (in 'string', line 864, column 8 to column 42)",
                                                      " (in 'string', line 865, column 21 to column 31)",
                                                      " (in 'string', line 865, column 8 to column 65)",
                                                      " (in 'string', line 886, column 10 to column 27)",
                                                      " (in 'string', line 885, column 15 to line 887, column 9)",
                                                      " (in 'string', line 868, column 17 to column 29)",
                                                      " (in 'string', line 868, column 10 to line 881, column 34)",
                                                      " (in 'string', line 884, column 10 to column 43)",
                                                      " (in 'string', line 866, column 36 to line 885, column 9)",
                                                      " (in 'string', line 866, column 8 to line 887, column 9)",
                                                      " (in 'string', line 862, column 29 to line 888, column 7)",
                                                      " (in 'string', line 862, column 6 to line 888, column 7)",
                                                      " (in 'string', line 889, column 6 to column 29)",
                                                      " (in 'string', line 858, column 11 to line 890, column 5)",
                                                      " (in 'string', line 850, column 13 to column 20)",
                                                      " (in 'string', line 850, column 6 to column 28)",
                                                      " (in 'string', line 852, column 8 to column 37)",
                                                      " (in 'string', line 853, column 8 to column 42)",
                                                      " (in 'string', line 854, column 21 to column 31)",
                                                      " (in 'string', line 854, column 8 to column 65)",
                                                      " (in 'string', line 855, column 8 to column 101)",
                                                      " (in 'string', line 851, column 29 to line 856, column 7)",
                                                      " (in 'string', line 851, column 6 to line 856, column 7)",
                                                      " (in 'string', line 857, column 6 to column 35)",
                                                      " (in 'string', line 847, column 27 to line 858, column 5)",
                                                      " (in 'string', line 847, column 4 to line 890, column 5)",
                                                      " (in 'string', line 846, column 16 to line 891, column 3)",
                                                      " (in 'string', line 846, column 2 to line 891, column 3)",
                                                      " (in 'string', line 896, column 4 to line 900, column 59)",
                                                      " (in 'string', line 902, column 6 to column 118)",
                                                      " (in 'string', line 903, column 6 to column 118)",
                                                      " (in 'string', line 901, column 27 to line 904, column 5)",
                                                      " (in 'string', line 901, column 4 to line 904, column 5)",
                                                      " (in 'string', line 906, column 4 to column 70)",
                                                      " (in 'string', line 893, column 23 to line 908, column 3)",
                                                      " (in 'string', line 893, column 2 to line 908, column 3)",
                                                      " (in 'string', line 909, column 2 to column 64)",
                                                      " (in 'string', line 912, column 6 to column 109)",
                                                      " (in 'string', line 911, column 4 to line 912, column 109)",
                                                      " (in 'string', line 910, column 2 to line 912, column 109)",
                                                      " (in 'string', line 913, column 2 to column 58)",
                                                      " (in 'string', line 917, column 6 to column 39)",
                                                      " (in 'string', line 916, column 4 to line 917, column 39)",
                                                      " (in 'string', line 918, column 4 to column 30)",
                                                      " (in 'string', line 915, column 25 to line 919, column 3)",
                                                      " (in 'string', line 915, column 2 to line 919, column 3)",
                                                      " (in 'string', line 924, column 6 to column 85)",
                                                      " (in 'string', line 922, column 25 to line 925, column 5)",
                                                      " (in 'string', line 922, column 4 to line 925, column 5)",
                                                      " (in 'string', line 926, column 4 to column 72)",
                                                      " (in 'string', line 921, column 38 to line 927, column 3)",
                                                      " (in 'string', line 921, column 2 to line 927, column 3)",
                                                      " (in 'string', line 569, column 2 to column 23)",
                                                      " (in 'string', line 570, column 17 to column 24)",
                                                      " (in 'string', line 570, column 2 to column 26)",
                                                      " (in 'string', line 571, column 18 to column 25)",
                                                      " (in 'string', line 571, column 2 to column 27)",
                                                      " (in 'string', line 573, column 2 to column 24)",
                                                      " (in 'string', line 575, column 27 to column 35)",
                                                      " (in 'string', line 575, column 9 to column 16)",
                                                      " (in 'string', line 575, column 2 to column 37)",
                                                      " (in 'string', line 577, column 2 to column 25)",
                                                      " (in 'string', line 578, column 9 to column 16)",
                                                      " (in 'string', line 578, column 17 to column 26)",
                                                      " (in 'string', line 578, column 2 to column 36)",
                                                      " (in 'string', line 581, column 21 to column 28)",
                                                      " (in 'string', line 581, column 2 to column 30)",
                                                      " (in 'string', line 583, column 23 to column 30)",
                                                      " (in 'string', line 583, column 2 to column 32)",
                                                      " (in 'string', line 585, column 2 to column 26)",
                                                      " (in 'string', line 587, column 2 to column 26)",
                                                      " (in 'string', line 589, column 50 to column 60)",
                                                      " (in 'string', line 589, column 2 to column 62)",
                                                      " (in 'string', line 591, column 43 to column 51)",
                                                      " (in 'string', line 591, column 2 to column 53)",
                                                      " (in 'string', line 592, column 44 to column 53)",
                                                      " (in 'string', line 592, column 2 to column 55)",
                                                      " (in 'string', line 597, column 29 to column 39)",
                                                      " (in 'string', line 597, column 40 to column 48)",
                                                      " (in 'string', line 597, column 2 to column 69)",
                                                      " (in 'string', line 598, column 29 to column 39)",
                                                      " (in 'string', line 598, column 40 to column 49)",
                                                      " (in 'string', line 598, column 2 to column 71)",
                                                      " (in 'string', line 600, column 34 to column 42)",
                                                      " (in 'string', line 600, column 2 to column 44)",
                                                      " (in 'string', line 601, column 41 to column 49)",
                                                      " (in 'string', line 601, column 2 to column 51)",
                                                      " (in 'string', line 602, column 2 to column 47)",
                                                      " (in 'string', line 603, column 35 to column 45)",
                                                      " (in 'string', line 603, column 46 to column 54)",
                                                      " (in 'string', line 603, column 2 to column 56)",
                                                      " (in 'string', line 604, column 42 to column 52)",
                                                      " (in 'string', line 604, column 53 to column 61)",
                                                      " (in 'string', line 604, column 2 to column 63)",
                                                      " (in 'string', line 605, column 39 to column 47)",
                                                      " (in 'string', line 605, column 2 to column 49)",
                                                      " (in 'string', line 606, column 9 to column 18)",
                                                      " (in 'string', line 606, column 2 to column 43)",
                                                      " (in 'string', line 607, column 18 to column 27)",
                                                      " (in 'string', line 607, column 2 to column 50)",
                                                      " (in 'string', line 608, column 44 to column 54)",
                                                      " (in 'string', line 608, column 9 to column 18)",
                                                      " (in 'string', line 608, column 2 to column 56)",
                                                      " (in 'string', line 609, column 51 to column 61)",
                                                      " (in 'string', line 609, column 18 to column 27)",
                                                      " (in 'string', line 609, column 2 to column 63)",
                                                      " (in 'string', line 610, column 2 to column 40)",
                                                      " (in 'string', line 612, column 35 to column 43)",
                                                      " (in 'string', line 612, column 2 to column 45)",
                                                      " (in 'string', line 613, column 42 to column 50)",
                                                      " (in 'string', line 613, column 2 to column 52)",
                                                      " (in 'string', line 614, column 9 to column 18)",
                                                      " (in 'string', line 614, column 2 to column 44)",
                                                      " (in 'string', line 615, column 18 to column 27)",
                                                      " (in 'string', line 615, column 2 to column 51)",
                                                      " (in 'string', line 620, column 2 to column 38)",
                                                      " (in 'string', line 622, column 2 to column 32)",
                                                      " (in 'string', line 625, column 17 to column 24)",
                                                      " (in 'string', line 625, column 2 to column 26)",
                                                      " (in 'string', line 626, column 34 to column 42)",
                                                      " (in 'string', line 626, column 43 to column 50)",
                                                      " (in 'string', line 626, column 2 to column 52)",
                                                      " (in 'string', line 627, column 2 to column 72)",
                                                      " (in 'string', line 628, column 2 to column 75)",
                                                      " (in 'string', line 629, column 2 to column 62)",
                                                      " (in 'string', line 630, column 2 to column 56)",
                                                      " (in 'string', line 631, column 49 to column 63)",
                                                      " (in 'string', line 631, column 64 to column 114)",
                                                      " (in 'string', line 631, column 2 to column 116)",
                                                      " (in 'string', line 632, column 48 to column 63)",
                                                      " (in 'string', line 632, column 64 to column 114)",
                                                      " (in 'string', line 632, column 2 to column 116)",
                                                      " (in 'string', line 633, column 36 to column 48)",
                                                      " (in 'string', line 633, column 49 to column 57)",
                                                      " (in 'string', line 633, column 2 to column 59)",
                                                      " (in 'string', line 634, column 36 to column 48)",
                                                      " (in 'string', line 634, column 49 to column 58)",
                                                      " (in 'string', line 634, column 2 to column 60)",
                                                      " (in 'string', line 636, column 43 to column 53)",
                                                      " (in 'string', line 636, column 2 to column 100)",
                                                      " (in 'string', line 638, column 31 to column 41)",
                                                      " (in 'string', line 638, column 2 to column 70)",
                                                      " (in 'string', line 640, column 43 to column 53)",
                                                      " (in 'string', line 640, column 54 to column 72)",
                                                      " (in 'string', line 640, column 2 to column 121)",
                                                      " (in 'string', line 641, column 47 to column 57)",
                                                      " (in 'string', line 641, column 18 to column 30)",
                                                      " (in 'string', line 641, column 2 to column 59)",
                                                      " (in 'string', line 642, column 9 to column 19)",
                                                      " (in 'string', line 642, column 2 to column 70)",
                                                      " (in 'string', line 645, column 4 to column 14)",
                                                      " (in 'string', line 648, column 8 to column 31)",
                                                      " (in 'string', line 649, column 8 to column 18)",
                                                      " (in 'string', line 647, column 24 to line 650, column 7)",
                                                      " (in 'string', line 647, column 6 to line 650, column 7)",
                                                      " (in 'string', line 646, column 25 to line 651, column 5)",
                                                      " (in 'string', line 646, column 4 to line 651, column 5)",
                                                      " (in 'string', line 644, column 26 to line 652, column 3)",
                                                      " (in 'string', line 644, column 2 to line 652, column 3)",
                                                      " (in 'string', line 656, column 4 to column 38)",
                                                      " (in 'string', line 657, column 17 to column 27)",
                                                      " (in 'string', line 657, column 4 to column 61)",
                                                      " (in 'string', line 659, column 6 to column 62)",
                                                      " (in 'string', line 658, column 4 to line 659, column 62)",
                                                      " (in 'string', line 655, column 25 to line 660, column 3)",
                                                      " (in 'string', line 655, column 2 to line 660, column 3)",
                                                      " (in 'string', line 662, column 11 to column 18)",
                                                      " (in 'string', line 662, column 4 to column 53)",
                                                      " (in 'string', line 664, column 6 to column 73)",
                                                      " (in 'string', line 663, column 4 to line 664, column 73)",
                                                      " (in 'string', line 661, column 23 to line 665, column 3)",
                                                      " (in 'string', line 661, column 2 to line 665, column 3)",
                                                      " (in 'string', line 667, column 11 to column 18)",
                                                      " (in 'string', line 667, column 4 to column 53)",
                                                      " (in 'string', line 669, column 6 to column 98)",
                                                      " (in 'string', line 668, column 4 to line 669, column 98)",
                                                      " (in 'string', line 666, column 20 to line 670, column 3)",
                                                      " (in 'string', line 666, column 2 to line 670, column 3)",
                                                      " (in 'string', line 673, column 4 to column 24)",
                                                      " (in 'string', line 674, column 4 to column 58)",
                                                      " (in 'string', line 672, column 22 to line 675, column 3)",
                                                      " (in 'string', line 672, column 2 to line 675, column 3)",
                                                      " (in 'string', line 678, column 4 to column 38)",
                                                      " (in 'string', line 679, column 17 to column 27)",
                                                      " (in 'string', line 679, column 4 to column 61)",
                                                      " (in 'string', line 680, column 4 to column 42)",
                                                      " (in 'string', line 677, column 25 to line 681, column 3)",
                                                      " (in 'string', line 677, column 2 to line 681, column 3)",
                                                      " (in 'string', line 683, column 23 to column 30)",
                                                      " (in 'string', line 683, column 4 to column 56)",
                                                      " (in 'string', line 686, column 8 to column 83)",
                                                      " (in 'string', line 687, column 8 to column 64)",
                                                      " (in 'string', line 685, column 26 to line 688, column 7)",
                                                      " (in 'string', line 685, column 6 to line 688, column 7)",
                                                      " (in 'string', line 684, column 25 to line 689, column 5)",
                                                      " (in 'string', line 684, column 4 to line 689, column 5)",
                                                      " (in 'string', line 692, column 8 to column 59)",
                                                      " (in 'string', line 691, column 6 to line 692, column 59)",
                                                      " (in 'string', line 690, column 24 to line 693, column 5)",
                                                      " (in 'string', line 690, column 4 to line 693, column 5)",
                                                      " (in 'string', line 682, column 2 to line 694, column 3)",
                                                      " (in 'string', line 695, column 2 to column 42)",
                                                      " (in 'string', line 696, column 2 to column 42)",
                                                      " (in 'string', line 697, column 2 to column 101)",
                                                      " (in 'string', line 698, column 2 to column 104)",
                                                      " (in 'string', line 699, column 2 to column 100)",
                                                      " (in 'string', line 700, column 2 to column 44)",
                                                      " (in 'string', line 702, column 4 to column 66)",
                                                      " (in 'string', line 701, column 25 to line 703, column 3)",
                                                      " (in 'string', line 701, column 2 to line 703, column 3)",
                                                      " (in 'string', line 704, column 2 to column 12)",
                                                      " (in 'string', line 705, column 2 to column 40)",
                                                      " (in 'string', line 707, column 4 to column 43)",
                                                      " (in 'string', line 706, column 25 to line 708, column 3)",
                                                      " (in 'string', line 706, column 2 to line 708, column 3)",
                                                      " (in 'string', line 709, column 2 to column 49)",
                                                      " (in 'string', line 715, column 4 to column 30)",
                                                      " (in 'string', line 714, column 34 to line 716, column 3)",
                                                      " (in 'string', line 714, column 9 to line 716, column 3)",
                                                      " (in 'string', line 713, column 4 to column 24)",
                                                      " (in 'string', line 712, column 34 to line 714, column 3)",
                                                      " (in 'string', line 712, column 9 to line 716, column 3)",
                                                      " (in 'string', line 711, column 4 to column 19)",
                                                      " (in 'string', line 710, column 26 to line 712, column 3)",
                                                      " (in 'string', line 710, column 2 to line 716, column 3)",
                                                      " (in 'string', line 718, column 4 to column 64)",
                                                      " (in 'string', line 717, column 2 to line 718, column 64)",
                                                      " (in 'string', line 720, column 4 to column 54)",
                                                      " (in 'string', line 719, column 2 to line 720, column 54)",
                                                      " (in 'string', line 725, column 21 to column 32)",
                                                      " (in 'string', line 725, column 4 to column 70)",
                                                      " (in 'string', line 726, column 16 to column 36)",
                                                      " (in 'string', line 726, column 4 to column 38)",
                                                      " (in 'string', line 729, column 6 to column 27)",
                                                      " (in 'string', line 727, column 28 to line 730, column 5)",
                                                      " (in 'string', line 727, column 4 to line 730, column 5)",
                                                      " (in 'string', line 732, column 6 to column 16)",
                                                      " (in 'string', line 740, column 10 to column 25)",
                                                      " (in 'string', line 739, column 15 to line 741, column 9)",
                                                      " (in 'string', line 737, column 10 to column 39)",
                                                      " (in 'string', line 738, column 10 to column 17)",
                                                      " (in 'string', line 736, column 36 to line 739, column 9)",
                                                      " (in 'string', line 736, column 8 to line 741, column 9)",
                                                      " (in 'string', line 733, column 27 to line 742, column 7)",
                                                      " (in 'string', line 733, column 6 to line 742, column 7)",
                                                      " (in 'string', line 731, column 4 to line 743, column 5)",
                                                      " (in 'string', line 745, column 6 to column 16)",
                                                      " (in 'string', line 753, column 10 to column 36)",
                                                      " (in 'string', line 752, column 15 to line 754, column 9)",
                                                      " (in 'string', line 750, column 10 to column 67)",
                                                      " (in 'string', line 751, column 10 to column 17)",
                                                      " (in 'string', line 749, column 37 to line 752, column 9)",
                                                      " (in 'string', line 749, column 8 to line 754, column 9)",
                                                      " (in 'string', line 746, column 28 to line 755, column 7)",
                                                      " (in 'string', line 746, column 6 to line 755, column 7)",
                                                      " (in 'string', line 744, column 4 to line 756, column 5)",
                                                      " (in 'string', line 762, column 10 to column 113)",
                                                      " (in 'string', line 761, column 8 to line 762, column 113)",
                                                      " (in 'string', line 760, column 6 to line 762, column 113)",
                                                      " (in 'string', line 765, column 10 to column 126)",
                                                      " (in 'string', line 764, column 8 to line 765, column 126)",
                                                      " (in 'string', line 763, column 6 to line 765, column 126)",
                                                      " (in 'string', line 767, column 6 to column 44)",
                                                      " (in 'string', line 768, column 6 to column 62)",
                                                      " (in 'string', line 757, column 27 to line 769, column 5)",
                                                      " (in 'string', line 757, column 4 to line 769, column 5)",
                                                      " (in 'string', line 724, column 27 to line 770, column 3)",
                                                      " (in 'string', line 724, column 2 to line 770, column 3)",
                                                      " (in 'string', line 774, column 4 to column 14)",
                                                      " (in 'string', line 777, column 8 to column 61)",
                                                      " (in 'string', line 778, column 8 to column 15)",
                                                      " (in 'string', line 776, column 34 to line 779, column 7)",
                                                      " (in 'string', line 776, column 6 to line 779, column 7)",
                                                      " (in 'string', line 775, column 25 to line 780, column 5)",
                                                      " (in 'string', line 775, column 4 to line 780, column 5)",
                                                      " (in 'string', line 773, column 2 to line 781, column 3)",
                                                      " (in 'string', line 783, column 4 to column 14)",
                                                      " (in 'string', line 786, column 8 to column 59)",
                                                      " (in 'string', line 787, column 8 to column 15)",
                                                      " (in 'string', line 785, column 35 to line 788, column 7)",
                                                      " (in 'string', line 785, column 6 to line 788, column 7)",
                                                      " (in 'string', line 784, column 26 to line 789, column 5)",
                                                      " (in 'string', line 784, column 4 to line 789, column 5)",
                                                      " (in 'string', line 782, column 2 to line 790, column 3)",
                                                      " (in 'string', line 795, column 25 to column 37)",
                                                      " (in 'string', line 795, column 38 to column 46)",
                                                      " (in 'string', line 796, column 28 to column 40)",
                                                      " (in 'string', line 796, column 9 to column 18)",
                                                      " (in 'string', line 798, column 24 to column 32)",
                                                      " (in 'string', line 801, column 38 to column 48)",
                                                      " (in 'string', line 801, column 49 to column 57)",
                                                      " (in 'string', line 803, column 42 to column 50)",
                                                      " (in 'string', line 805, column 9 to column 18)",
                                                      " (in 'string', line 806, column 41 to column 51)",
                                                      " (in 'string', line 806, column 18 to column 27)",
                                                      " (in 'string', line 807, column 23 to column 32)",
                                                      " (in 'string', line 815, column 17 to column 29)",
                                                      " (in 'string', line 815, column 30 to column 38)",
                                                      " (in 'string', line 816, column 24 to column 36)",
                                                      " (in 'string', line 816, column 9 to column 18)",
                                                      " (in 'string', line 817, column 34 to column 44)",
                                                      " (in 'string', line 817, column 45 to column 53)",
                                                      " (in 'string', line 818, column 37 to column 47)",
                                                      " (in 'string', line 818, column 18 to column 27)",
                                                      " (in 'string', line 930, column 9 to column 19)",
                                                      " (in 'string', line 930, column 20 to column 28)",
                                                      " (in 'string', line 931, column 9 to column 19)",
                                                      " (in 'string', line 931, column 20 to column 29)",
                                                      " (in 'string', line 932, column 23 to column 33)",
                                                      " (in 'string', line 932, column 34 to column 42)",
                                                      " (in 'string', line 933, column 30 to column 40)",
                                                      " (in 'string', line 933, column 9 to column 18)",
                                                      " (in 'string', line 934, column 9 to column 19)",
                                                      " (in 'string', line 935, column 9 to column 17)",
                                                      " (in 'string', line 936, column 9 to column 18)",
                                                      " (in 'string', line 936, column 19 to column 28)",
                                                      " (in 'string', line 19, column 9 to column 18)",
                                                      " (in 'string', line 19, column 2 to column 20)",
                                                      " (in 'string', line 20, column 2 to column 13)",
                                                      " (in 'string', line 21, column 2 to column 13)",
                                                      " (in 'string', line 23, column 4 to column 19)",
                                                      " (in 'string', line 24, column 4 to column 17)",
                                                      " (in 'string', line 22, column 22 to line 25, column 3)",
                                                      " (in 'string', line 22, column 2 to line 25, column 3)",
                                                      " (in 'string', line 26, column 2 to column 13)",
                                                      " (in 'string', line 18, column 32 to line 27, column 1)",
                                                      " (in 'string', line 30, column 2 to column 12)",
                                                      " (in 'string', line 33, column 6 to column 16)",
                                                      " (in 'string', line 32, column 4 to line 33, column 16)",
                                                      " (in 'string', line 31, column 32 to line 34, column 3)",
                                                      " (in 'string', line 31, column 2 to line 34, column 3)",
                                                      " (in 'string', line 35, column 2 to column 12)",
                                                      " (in 'string', line 29, column 30 to line 36, column 1)",
                                                      " (in 'string', line 39, column 2 to column 12)",
                                                      " (in 'string', line 42, column 6 to column 16)",
                                                      " (in 'string', line 41, column 4 to line 42, column 16)",
                                                      " (in 'string', line 40, column 32 to line 43, column 3)",
                                                      " (in 'string', line 40, column 2 to line 43, column 3)",
                                                      " (in 'string', line 44, column 2 to column 12)",
                                                      " (in 'string', line 38, column 38 to line 45, column 1)",
                                                      " (in 'string', line 49, column 10 to column 29)",
                                                      " (in 'string', line 49, column 2 to column 31)",
                                                      " (in 'string', line 50, column 2 to column 12)",
                                                      " (in 'string', line 51, column 2 to column 13)",
                                                      " (in 'string', line 56, column 6 to column 16)",
                                                      " (in 'string', line 57, column 6 to column 17)",
                                                      " (in 'string', line 55, column 11 to line 58, column 5)",
                                                      " (in 'string', line 54, column 6 to column 26)",
                                                      " (in 'string', line 53, column 27 to line 55, column 5)",
                                                      " (in 'string', line 53, column 4 to line 58, column 5)",
                                                      " (in 'string', line 52, column 32 to line 59, column 3)",
                                                      " (in 'string', line 52, column 2 to line 59, column 3)",
                                                      " (in 'string', line 60, column 2 to column 14)",
                                                      " (in 'string', line 48, column 25 to line 61, column 1)",
                                                      " (in 'string', line 64, column 2 to column 30)",
                                                      " (in 'string', line 65, column 16 to column 17)",
                                                      " (in 'string', line 65, column 2 to column 57)",
                                                      " (in 'string', line 66, column 2 to column 24)",
                                                      " (in 'string', line 63, column 30 to line 67, column 1)",
                                                      " (in 'string', line 76, column 2 to column 29)",
                                                      " (in 'string', line 77, column 17 to column 18)",
                                                      " (in 'string', line 77, column 2 to column 49)",
                                                      " (in 'string', line 78, column 2 to column 26)",
                                                      " (in 'string', line 81, column 6 to column 79)",
                                                      " (in 'string', line 80, column 4 to line 81, column 79)",
                                                      " (in 'string', line 79, column 18 to line 82, column 3)",
                                                      " (in 'string', line 79, column 2 to line 82, column 3)",
                                                      " (in 'string', line 75, column 35 to line 83, column 1)",
                                                      " (in 'string', line 85, column 15 to column 21)",
                                                      " (in 'string', line 85, column 2 to column 23)",
                                                      " (in 'string', line 86, column 2 to column 24)",
                                                      " (in 'string', line 88, column 4 to column 33)",
                                                      " (in 'string', line 89, column 4 to column 29)",
                                                      " (in 'string', line 87, column 21 to line 90, column 3)",
                                                      " (in 'string', line 87, column 2 to line 90, column 3)",
                                                      " (in 'string', line 91, column 2 to column 18)",
                                                      " (in 'string', line 84, column 54 to line 92, column 1)",
                                                      " (in 'string', line 96, column 4 to column 88)",
                                                      " (in 'string', line 95, column 2 to line 96, column 88)",
                                                      " (in 'string', line 100, column 4 to column 49)",
                                                      " (in 'string', line 98, column 4 to column 13)",
                                                      " (in 'string', line 97, column 2 to line 100, column 49)",
                                                      " (in 'string', line 94, column 37 to line 101, column 1)",
                                                      " (in 'string', line 104, column 2 to column 41)",
                                                      " (in 'string', line 103, column 33 to line 105, column 1)",
                                                      " (in 'string', line 108, column 9 to column 28)",
                                                      " (in 'string', line 108, column 2 to column 63)",
                                                      " (in 'string', line 109, column 2 to column 47)",
                                                      " (in 'string', line 107, column 37 to line 110, column 1)",
                                                      " (in 'string', line 113, column 2 to column 26)",
                                                      " (in 'string', line 114, column 10 to column 11)",
                                                      " (in 'string', line 114, column 2 to column 13)",
                                                      " (in 'string', line 115, column 16 to column 39)",
                                                      " (in 'string', line 115, column 2 to column 39)",
                                                      " (in 'string', line 116, column 2 to column 14)",
                                                      " (in 'string', line 112, column 34 to line 117, column 1)",
                                                      " (in 'string', line 121, column 2 to column 20)",
                                                      " (in 'string', line 122, column 17 to column 18)",
                                                      " (in 'string', line 122, column 2 to column 20)",
                                                      " (in 'string', line 123, column 2 to column 12)",
                                                      " (in 'string', line 125, column 4 to column 59)",
                                                      " (in 'string', line 126, column 4 to column 20)",
                                                      " (in 'string', line 124, column 24 to line 127, column 3)",
                                                      " (in 'string', line 124, column 2 to line 127, column 3)",
                                                      " (in 'string', line 128, column 2 to column 21)",
                                                      " (in 'string', line 120, column 38 to line 129, column 1)",
                                                      " (in 'string', line 150, column 2 to column 72)",
                                                      " (in 'string', line 149, column 40 to line 151, column 1)",
                                                      " (in 'string', line 158, column 10 to column 25)",
                                                      " (in 'string', line 158, column 2 to column 27)",
                                                      " (in 'string', line 162, column 4 to column 62)",
                                                      " (in 'string', line 161, column 30 to line 163, column 3)",
                                                      " (in 'string', line 161, column 2 to line 163, column 3)",
                                                      " (in 'string', line 164, column 2 to column 14)",
                                                      " (in 'string', line 157, column 50 to line 165, column 1)",
                                                      " (in 'string', line 170, column 2 to column 10)",
                                                      " (in 'string', line 171, column 2 to column 8)",
                                                      " (in 'string', line 172, column 2 to column 15)",
                                                      " (in 'string', line 173, column 2 to column 12)",
                                                      " (in 'string', line 174, column 2 to column 13)",
                                                      " (in 'string', line 175, column 2 to column 15)",
                                                      " (in 'string', line 176, column 2 to column 16)",
                                                      " (in 'string', line 177, column 2 to column 11)",
                                                      " (in 'string', line 178, column 2 to column 27)",
                                                      " (in 'string', line 179, column 13 to column 23)",
                                                      " (in 'string', line 179, column 2 to column 23)",
                                                      " (in 'string', line 180, column 2 to column 23)",
                                                      " (in 'string', line 181, column 2 to column 16)",
                                                      " (in 'string', line 182, column 2 to column 21)",
                                                      " (in 'string', line 183, column 2 to column 31)",
                                                      " (in 'string', line 184, column 2 to column 32)",
                                                      " (in 'string', line 185, column 16 to column 35)",
                                                      " (in 'string', line 185, column 2 to column 35)",
                                                      " (in 'string', line 186, column 17 to column 29)",
                                                      " (in 'string', line 186, column 2 to column 29)",
                                                      " (in 'string', line 187, column 16 to column 26)",
                                                      " (in 'string', line 187, column 2 to column 26)",
                                                      " (in 'string', line 188, column 2 to column 11)",
                                                      " (in 'string', line 190, column 4 to column 16)",
                                                      " (in 'string', line 191, column 4 to column 13)",
                                                      " (in 'string', line 194, column 4 to column 41)",
                                                      " (in 'string', line 195, column 4 to column 30)",
                                                      " (in 'string', line 196, column 18 to column 36)",
                                                      " (in 'string', line 196, column 4 to column 36)",
                                                      " (in 'string', line 197, column 26 to column 38)",
                                                      " (in 'string', line 197, column 39 to column 59)",
                                                      " (in 'string', line 197, column 24 to column 61)",
                                                      " (in 'string', line 197, column 4 to column 61)",
                                                      " (in 'string', line 198, column 27 to column 38)",
                                                      " (in 'string', line 198, column 39 to column 58)",
                                                      " (in 'string', line 198, column 25 to column 60)",
                                                      " (in 'string', line 198, column 4 to column 60)",
                                                      " (in 'string', line 199, column 4 to column 20)",
                                                      " (in 'string', line 189, column 56 to line 200, column 3)",
                                                      " (in 'string', line 189, column 2 to line 200, column 3)",
                                                      " (in 'string', line 202, column 4 to column 51)",
                                                      " (in 'string', line 201, column 2 to line 202, column 51)",
                                                      " (in 'string', line 203, column 2 to column 19)",
                                                      " (in 'string', line 169, column 61 to line 204, column 1)",
                                                      " (in 'string', line 206, column 10 to column 25)",
                                                      " (in 'string', line 206, column 2 to column 27)",
                                                      " (in 'string', line 208, column 4 to column 49)",
                                                      " (in 'string', line 207, column 30 to line 209, column 3)",
                                                      " (in 'string', line 207, column 2 to line 209, column 3)",
                                                      " (in 'string', line 210, column 2 to column 14)",
                                                      " (in 'string', line 205, column 45 to line 211, column 1)",
                                                      " (in 'string', line 215, column 10 to column 25)",
                                                      " (in 'string', line 215, column 2 to column 27)",
                                                      " (in 'string', line 216, column 2 to column 11)",
                                                      " (in 'string', line 217, column 2 to column 11)",
                                                      " (in 'string', line 219, column 4 to column 52)",
                                                      " (in 'string', line 220, column 19 to column 33)",
                                                      " (in 'string', line 220, column 4 to column 33)",
                                                      " (in 'string', line 218, column 30 to line 221, column 3)",
                                                      " (in 'string', line 218, column 2 to line 221, column 3)",
                                                      " (in 'string', line 222, column 2 to column 14)",
                                                      " (in 'string', line 214, column 49 to line 223, column 1)",
                                                      " (in 'string', line 225, column 10 to column 28)",
                                                      " (in 'string', line 225, column 2 to column 30)",
                                                      " (in 'string', line 226, column 2 to column 8)",
                                                      " (in 'string', line 227, column 2 to column 8)",
                                                      " (in 'string', line 228, column 2 to column 8)",
                                                      " (in 'string', line 229, column 2 to column 27)",
                                                      " (in 'string', line 230, column 2 to column 8)",
                                                      " (in 'string', line 231, column 2 to column 8)",
                                                      " (in 'string', line 233, column 13 to column 22)",
                                                      " (in 'string', line 233, column 4 to column 24)",
                                                      " (in 'string', line 234, column 4 to column 87)",
                                                      " (in 'string', line 236, column 6 to column 31)",
                                                      " (in 'string', line 235, column 4 to line 236, column 31)",
                                                      " (in 'string', line 237, column 4 to column 22)",
                                                      " (in 'string', line 238, column 4 to column 24)",
                                                      " (in 'string', line 232, column 16 to line 239, column 3)",
                                                      " (in 'string', line 232, column 2 to line 239, column 3)",
                                                      " (in 'string', line 240, column 2 to column 14)",
                                                      " (in 'string', line 224, column 86 to line 241, column 1)",
                                                      " (in 'string', line 244, column 2 to column 12)",
                                                      " (in 'string', line 245, column 2 to column 12)",
                                                      " (in 'string', line 248, column 6 to column 24)",
                                                      " (in 'string', line 247, column 4 to line 248, column 24)",
                                                      " (in 'string', line 246, column 2 to line 248, column 24)",
                                                      " (in 'string', line 249, column 2 to column 16)",
                                                      " (in 'string', line 243, column 37 to line 250, column 1)",
                                                      " (in 'string', line 253, column 13 to column 32)",
                                                      " (in 'string', line 253, column 2 to column 34)",
                                                      " (in 'string', line 255, column 4 to column 43)",
                                                      " (in 'string', line 254, column 2 to line 255, column 43)",
                                                      " (in 'string', line 256, column 2 to column 17)",
                                                      " (in 'string', line 252, column 43 to line 257, column 1)",
                                                      " (in 'string', line 260, column 10 to column 32)",
                                                      " (in 'string', line 260, column 2 to column 34)",
                                                      " (in 'string', line 261, column 2 to column 9)",
                                                      " (in 'string', line 262, column 2 to column 9)",
                                                      " (in 'string', line 265, column 6 to column 18)",
                                                      " (in 'string', line 266, column 6 to column 18)",
                                                      " (in 'string', line 264, column 24 to line 267, column 5)",
                                                      " (in 'string', line 264, column 4 to line 267, column 5)",
                                                      " (in 'string', line 263, column 2 to line 267, column 5)",
                                                      " (in 'string', line 268, column 2 to column 14)",
                                                      " (in 'string', line 259, column 39 to line 269, column 1)",
                                                      " (in 'string', line 272, column 2 to column 12)",
                                                      " (in 'string', line 274, column 4 to column 60)",
                                                      " (in 'string', line 273, column 2 to line 274, column 60)",
                                                      " (in 'string', line 275, column 2 to column 12)",
                                                      " (in 'string', line 276, column 30 to column 48)",
                                                      " (in 'string', line 276, column 28 to column 50)",
                                                      " (in 'string', line 276, column 2 to column 50)",
                                                      " (in 'string', line 277, column 2 to column 20)",
                                                      " (in 'string', line 278, column 2 to column 15)",
                                                      " (in 'string', line 271, column 38 to line 279, column 1)",
                                                      " (in 'string', line 281, column 20 to column 25)",
                                                      " (in 'string', line 281, column 2 to column 27)",
                                                      " (in 'string', line 282, column 2 to column 8)",
                                                      " (in 'string', line 283, column 2 to column 8)",
                                                      " (in 'string', line 284, column 2 to column 38)",
                                                      " (in 'string', line 285, column 2 to column 8)",
                                                      " (in 'string', line 286, column 2 to column 25)",
                                                      " (in 'string', line 287, column 44 to column 54)",
                                                      " (in 'string', line 287, column 42 to column 56)",
                                                      " (in 'string', line 287, column 2 to column 56)",
                                                      " (in 'string', line 289, column 4 to column 14)",
                                                      " (in 'string', line 290, column 4 to column 14)",
                                                      " (in 'string', line 292, column 6 to column 16)",
                                                      " (in 'string', line 293, column 6 to column 24)",
                                                      " (in 'string', line 291, column 43 to line 294, column 5)",
                                                      " (in 'string', line 291, column 4 to line 294, column 5)",
                                                      " (in 'string', line 295, column 4 to column 29)",
                                                      " (in 'string', line 288, column 21 to line 296, column 3)",
                                                      " (in 'string', line 288, column 2 to line 296, column 3)",
                                                      " (in 'string', line 297, column 2 to column 24)",
                                                      " (in 'string', line 280, column 58 to line 298, column 1)",
                                                      " (in 'string', line 300, column 20 to column 30)",
                                                      " (in 'string', line 300, column 2 to column 32)",
                                                      " (in 'string', line 301, column 2 to column 8)",
                                                      " (in 'string', line 302, column 2 to column 9)",
                                                      " (in 'string', line 303, column 2 to column 43)",
                                                      " (in 'string', line 304, column 2 to column 8)",
                                                      " (in 'string', line 305, column 2 to column 9)",
                                                      " (in 'string', line 307, column 4 to column 10)",
                                                      " (in 'string', line 308, column 4 to column 11)",
                                                      " (in 'string', line 309, column 4 to column 21)",
                                                      " (in 'string', line 310, column 4 to column 27)",
                                                      " (in 'string', line 311, column 4 to column 77)",
                                                      " (in 'string', line 312, column 4 to column 14)",
                                                      " (in 'string', line 313, column 4 to column 16)",
                                                      " (in 'string', line 306, column 23 to line 314, column 3)",
                                                      " (in 'string', line 306, column 2 to line 314, column 3)",
                                                      " (in 'string', line 315, column 2 to column 24)",
                                                      " (in 'string', line 299, column 77 to line 316, column 1)",
                                                      " (in 'string', line 325, column 10 to column 23)",
                                                      " (in 'string', line 325, column 2 to column 25)",
                                                      " (in 'string', line 327, column 4 to column 30)",
                                                      " (in 'string', line 326, column 2 to line 327, column 30)",
                                                      " (in 'string', line 328, column 2 to column 13)",
                                                      " (in 'string', line 324, column 44 to line 329, column 1)",
                                                      " (in 'string', line 331, column 9 to column 22)",
                                                      " (in 'string', line 331, column 2 to column 28)",
                                                      " (in 'string', line 333, column 4 to column 30)",
                                                      " (in 'string', line 332, column 2 to line 333, column 30)",
                                                      " (in 'string', line 334, column 2 to column 13)",
                                                      " (in 'string', line 330, column 46 to line 335, column 1)",
                                                      " (in 'string', line 337, column 9 to column 22)",
                                                      " (in 'string', line 337, column 23 to column 33)",
                                                      " (in 'string', line 337, column 2 to column 39)",
                                                      " (in 'string', line 339, column 4 to column 30)",
                                                      " (in 'string', line 338, column 2 to line 339, column 30)",
                                                      " (in 'string', line 340, column 2 to column 13)",
                                                      " (in 'string', line 336, column 49 to line 341, column 1)",
                                                      " (in 'string', line 345, column 2 to column 14)",
                                                      " (in 'string', line 346, column 2 to column 17)",
                                                      " (in 'string', line 347, column 2 to column 10)",
                                                      " (in 'string', line 355, column 8 to column 22)",
                                                      " (in 'string', line 354, column 13 to line 356, column 7)",
                                                      " (in 'string', line 352, column 10 to column 126)",
                                                      " (in 'string', line 351, column 8 to line 352, column 126)",
                                                      " (in 'string', line 353, column 8 to column 19)",
                                                      " (in 'string', line 350, column 27 to line 354, column 7)",
                                                      " (in 'string', line 350, column 6 to line 356, column 7)",
                                                      " (in 'string', line 349, column 21 to line 357, column 5)",
                                                      " (in 'string', line 349, column 4 to line 357, column 5)",
                                                      " (in 'string', line 348, column 31 to line 358, column 3)",
                                                      " (in 'string', line 348, column 2 to line 358, column 3)",
                                                      " (in 'string', line 360, column 4 to column 62)",
                                                      " (in 'string', line 359, column 2 to line 360, column 62)",
                                                      " (in 'string', line 344, column 25 to line 361, column 1)",
                                                      " (in 'string', line 366, column 2 to column 34)",
                                                      " (in 'string', line 369, column 6 to column 60)",
                                                      " (in 'string', line 368, column 4 to line 369, column 60)",
                                                      " (in 'string', line 367, column 16 to line 370, column 3)",
                                                      " (in 'string', line 367, column 2 to line 370, column 3)",
                                                      " (in 'string', line 365, column 75 to line 371, column 1)",
                                                      " (in 'string', line 373, column 2 to column 31)",
                                                      " (in 'string', line 374, column 2 to column 12)",
                                                      " (in 'string', line 376, column 4 to line 378, column 56)",
                                                      " (in 'string', line 379, column 4 to column 22)",
                                                      " (in 'string', line 375, column 16 to line 380, column 3)",
                                                      " (in 'string', line 375, column 2 to line 380, column 3)",
                                                      " (in 'string', line 372, column 97 to line 381, column 1)",
                                                      " (in 'string', line 390, column 6 to column 36)",
                                                      " (in 'string', line 389, column 26 to line 391, column 5)",
                                                      " (in 'string', line 389, column 11 to line 391, column 5)",
                                                      " (in 'string', line 388, column 6 to column 39)",
                                                      " (in 'string', line 387, column 26 to line 389, column 5)",
                                                      " (in 'string', line 387, column 11 to line 391, column 5)",
                                                      " (in 'string', line 386, column 6 to column 34)",
                                                      " (in 'string', line 383, column 19 to line 387, column 5)",
                                                      " (in 'string', line 383, column 4 to line 391, column 5)",
                                                      " (in 'string', line 392, column 4 to column 44)",
                                                      " (in 'string', line 393, column 4 to column 15)",
                                                      " (in 'string', line 382, column 58 to line 394, column 3)",
                                                      " (in 'string', line 397, column 4 to column 70)",
                                                      " (in 'string', line 396, column 50 to line 398, column 3)",
                                                      " (in 'string', line 409, column 4 to column 33)",
                                                      " (in 'string', line 410, column 4 to column 32)",
                                                      " (in 'string', line 411, column 4 to column 34)",
                                                      " (in 'string', line 412, column 11 to column 18)",
                                                      " (in 'string', line 412, column 4 to column 23)",
                                                      " (in 'string', line 414, column 6 to column 28)",
                                                      " (in 'string', line 415, column 6 to column 27)",
                                                      " (in 'string', line 423, column 12 to column 73)",
                                                      " (in 'string', line 422, column 32 to line 424, column 11)",
                                                      " (in 'string', line 422, column 10 to line 424, column 11)",
                                                      " (in 'string', line 420, column 29 to line 425, column 9)",
                                                      " (in 'string', line 420, column 8 to line 425, column 9)",
                                                      " (in 'string', line 427, column 8 to column 49)",
                                                      " (in 'string', line 419, column 13 to line 428, column 7)",
                                                      " (in 'string', line 418, column 8 to column 20)",
                                                      " (in 'string', line 416, column 22 to line 419, column 7)",
                                                      " (in 'string', line 416, column 6 to line 428, column 7)",
                                                      " (in 'string', line 431, column 8 to column 36)",
                                                      " (in 'string', line 430, column 24 to line 432, column 7)",
                                                      " (in 'string', line 430, column 6 to line 432, column 7)",
                                                      " (in 'string', line 413, column 24 to line 433, column 5)",
                                                      " (in 'string', line 413, column 4 to line 433, column 5)",
                                                      " (in 'string', line 434, column 4 to column 14)",
                                                      " (in 'string', line 408, column 52 to line 435, column 3)",
                                                      " (in 'string', line 472, column 4 to column 33)",
                                                      " (in 'string', line 473, column 14 to column 21)",
                                                      " (in 'string', line 473, column 4 to column 23)",
                                                      " (in 'string', line 474, column 14 to column 21)",
                                                      " (in 'string', line 474, column 4 to column 23)",
                                                      " (in 'string', line 476, column 6 to column 32)",
                                                      " (in 'string', line 477, column 6 to column 32)",
                                                      " (in 'string', line 475, column 24 to line 478, column 5)",
                                                      " (in 'string', line 475, column 4 to line 478, column 5)",
                                                      " (in 'string', line 479, column 4 to column 117)",
                                                      " (in 'string', line 471, column 44 to line 480, column 3)",
                                                      " (in 'string', line 486, column 4 to column 33)",
                                                      " (in 'string', line 487, column 14 to column 21)",
                                                      " (in 'string', line 487, column 4 to column 23)",
                                                      " (in 'string', line 488, column 15 to column 22)",
                                                      " (in 'string', line 488, column 4 to column 24)",
                                                      " (in 'string', line 489, column 11 to column 18)",
                                                      " (in 'string', line 489, column 4 to column 97)",
                                                      " (in 'string', line 490, column 11 to column 18)",
                                                      " (in 'string', line 490, column 4 to column 50)",
                                                      " (in 'string', line 491, column 11 to column 18)",
                                                      " (in 'string', line 491, column 4 to column 59)",
                                                      " (in 'string', line 493, column 6 to column 32)",
                                                      " (in 'string', line 494, column 6 to column 44)",
                                                      " (in 'string', line 492, column 24 to line 495, column 5)",
                                                      " (in 'string', line 492, column 4 to line 495, column 5)",
                                                      " (in 'string', line 496, column 4 to column 97)",
                                                      " (in 'string', line 485, column 50 to line 497, column 3)",
                                                      " (in 'string', line 506, column 4 to column 42)",
                                                      " (in 'string', line 507, column 4 to column 41)",
                                                      " (in 'string', line 508, column 4 to column 41)",
                                                      " (in 'string', line 509, column 11 to column 23)",
                                                      " (in 'string', line 509, column 4 to column 34)",
                                                      " (in 'string', line 511, column 6 to column 43)",
                                                      " (in 'string', line 510, column 4 to line 511, column 43)",
                                                      " (in 'string', line 513, column 19 to column 27)",
                                                      " (in 'string', line 513, column 6 to column 47)",
                                                      " (in 'string', line 514, column 18 to column 27)",
                                                      " (in 'string', line 514, column 6 to column 46)",
                                                      " (in 'string', line 515, column 32 to column 40)",
                                                      " (in 'string', line 515, column 6 to column 42)",
                                                      " (in 'string', line 516, column 13 to column 22)",
                                                      " (in 'string', line 516, column 6 to column 39)",
                                                      " (in 'string', line 518, column 8 to column 75)",
                                                      " (in 'string', line 517, column 6 to line 518, column 75)",
                                                      " (in 'string', line 520, column 8 to column 72)",
                                                      " (in 'string', line 519, column 6 to line 520, column 72)",
                                                      " (in 'string', line 521, column 6 to line 527, column 46)",
                                                      " (in 'string', line 512, column 29 to line 528, column 5)",
                                                      " (in 'string', line 512, column 4 to line 528, column 5)",
                                                      " (in 'string', line 529, column 4 to column 20)",
                                                      " (in 'string', line 505, column 62 to line 530, column 3)",
                                                      " (in 'string', line 540, column 4 to column 42)",
                                                      " (in 'string', line 541, column 4 to column 41)",
                                                      " (in 'string', line 542, column 4 to column 41)",
                                                      " (in 'string', line 543, column 11 to column 23)",
                                                      " (in 'string', line 543, column 4 to column 32)",
                                                      " (in 'string', line 545, column 6 to column 43)",
                                                      " (in 'string', line 544, column 4 to line 545, column 43)",
                                                      " (in 'string', line 547, column 19 to column 27)",
                                                      " (in 'string', line 547, column 6 to column 47)",
                                                      " (in 'string', line 548, column 18 to column 27)",
                                                      " (in 'string', line 548, column 6 to column 46)",
                                                      " (in 'string', line 549, column 32 to column 40)",
                                                      " (in 'string', line 549, column 6 to column 42)",
                                                      " (in 'string', line 550, column 13 to column 22)",
                                                      " (in 'string', line 550, column 6 to column 39)",
                                                      " (in 'string', line 552, column 8 to column 75)",
                                                      " (in 'string', line 551, column 6 to line 552, column 75)",
                                                      " (in 'string', line 554, column 8 to column 72)",
                                                      " (in 'string', line 553, column 6 to line 554, column 72)",
                                                      " (in 'string', line 555, column 6 to line 561, column 50)",
                                                      " (in 'string', line 546, column 29 to line 562, column 5)",
                                                      " (in 'string', line 546, column 4 to line 562, column 5)",
                                                      " (in 'string', line 563, column 4 to column 18)",
                                                      " (in 'string', line 539, column 62 to line 564, column 3)"};
std::vector<int>
make_slice_index(const std::vector<int>& S, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 402;
    validate_non_negative_index("Si", "size(S) + 1",
                                (stan::math::size(S) + 1));
    std::vector<int> Si;
    Si = std::vector<int>((stan::math::size(S) + 1), std::numeric_limits<int>::min());
    
    int cv;
    cv = std::numeric_limits<int>::min();
    
    current_statement__ = 404;
    cv = 1;
    current_statement__ = 405;
    assign(Si, cons_list(index_uni(1), nil_index_list()), cv,
      "assigning variable Si");
    current_statement__ = 409;
    for (int i = 1; i <= stan::math::size(S); ++i) {
      current_statement__ = 406;
      cv = (cv + S[(i - 1)]);
      current_statement__ = 407;
      assign(Si, cons_list(index_uni((i + 1)), nil_index_list()), cv,
        "assigning variable Si");}
    current_statement__ = 410;
    return Si;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct make_slice_index_functor__ {
std::vector<int>
operator()(const std::vector<int>& S, std::ostream* pstream__)  const 
{
return make_slice_index(S, pstream__);
}
};
int
rle_elem_count(const std::vector<int>& set, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int U;
    U = std::numeric_limits<int>::min();
    
    current_statement__ = 412;
    U = 1;
    current_statement__ = 416;
    for (int i = 2; i <= num_elements(set); ++i) {
      current_statement__ = 414;
      if (logical_neq(set[((i - 1) - 1)], set[(i - 1)])) {
        current_statement__ = 413;
        U = (U + 1);
      } }
    current_statement__ = 417;
    return U;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct rle_elem_count_functor__ {
int
operator()(const std::vector<int>& set, std::ostream* pstream__)  const 
{
return rle_elem_count(set, pstream__);
}
};
template <typename T0__>
int
rle_elem_count_vector(const T0__& set_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  const auto& set = to_ref(set_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int U;
    U = std::numeric_limits<int>::min();
    
    current_statement__ = 419;
    U = 1;
    current_statement__ = 423;
    for (int i = 2; i <= num_elements(set); ++i) {
      current_statement__ = 421;
      if (logical_neq(set[((i - 1) - 1)], set[(i - 1)])) {
        current_statement__ = 420;
        U = (U + 1);
      } }
    current_statement__ = 424;
    return U;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct rle_elem_count_vector_functor__ {
template <typename T0__>
int
operator()(const T0__& set, std::ostream* pstream__)  const 
{
return rle_elem_count_vector(set, pstream__);
}
};
std::vector<int>
rle_int(const std::vector<int>& set, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 426;
    validate_non_negative_index("res", "rle_elem_count(set)",
                                rle_elem_count(set, pstream__));
    std::vector<int> res;
    res = std::vector<int>(rle_elem_count(set, pstream__), std::numeric_limits<int>::min());
    
    int c;
    c = std::numeric_limits<int>::min();
    
    current_statement__ = 428;
    c = 1;
    current_statement__ = 429;
    assign(res, cons_list(index_uni(1), nil_index_list()), 1,
      "assigning variable res");
    current_statement__ = 437;
    for (int i = 2; i <= num_elements(set); ++i) {
      current_statement__ = 435;
      if (logical_eq(set[((i - 1) - 1)], set[(i - 1)])) {
        current_statement__ = 433;
        assign(res, cons_list(index_uni(c), nil_index_list()),
          (res[(c - 1)] + 1), "assigning variable res");
      } else {
        current_statement__ = 430;
        c = (c + 1);
        current_statement__ = 431;
        assign(res, cons_list(index_uni(c), nil_index_list()), 1,
          "assigning variable res");
      }}
    current_statement__ = 438;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct rle_int_functor__ {
std::vector<int>
operator()(const std::vector<int>& set, std::ostream* pstream__)  const 
{
return rle_int(set, pstream__);
}
};
std::vector<int>
rle_elem_int(const std::vector<int>& set, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int N;
    N = std::numeric_limits<int>::min();
    
    current_statement__ = 440;
    N = rle_elem_count(set, pstream__);
    current_statement__ = 441;
    validate_non_negative_index("first_ind", "N", N);
    std::vector<int> first_ind;
    first_ind = std::vector<int>(N, std::numeric_limits<int>::min());
    
    current_statement__ = 442;
    assign(first_ind, nil_index_list(),
      rvalue(make_slice_index(rle_int(set, pstream__), pstream__),
        cons_list(index_min_max(1, N), nil_index_list()),
        "make_slice_index(rle_int(set))"), "assigning variable first_ind");
    current_statement__ = 443;
    return rvalue(set, cons_list(index_multi(first_ind), nil_index_list()),
             "set");
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct rle_elem_int_functor__ {
std::vector<int>
operator()(const std::vector<int>& set, std::ostream* pstream__)  const 
{
return rle_elem_int(set, pstream__);
}
};
void
check_duplicate_ids(const std::vector<int>& id, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int N;
    N = std::numeric_limits<int>::min();
    
    current_statement__ = 445;
    N = rle_elem_count(id, pstream__);
    current_statement__ = 446;
    validate_non_negative_index("sorted_ids", "N", N);
    std::vector<int> sorted_ids;
    sorted_ids = std::vector<int>(N, std::numeric_limits<int>::min());
    
    current_statement__ = 447;
    assign(sorted_ids, nil_index_list(),
      sort_asc(rle_elem_int(id, pstream__)), "assigning variable sorted_ids");
    int cid;
    cid = std::numeric_limits<int>::min();
    
    current_statement__ = 448;
    cid = sorted_ids[(1 - 1)];
    current_statement__ = 452;
    for (int i = 1; i <= (N - 1); ++i) {
      current_statement__ = 450;
      if (logical_eq(sorted_ids[(i - 1)], sorted_ids[((i + 1) - 1)])) {
        current_statement__ = 449;
        std::stringstream errmsg_stream__;
        errmsg_stream__ << "ID ";
        errmsg_stream__ << sorted_ids[(i - 1)];
        errmsg_stream__ << " occurs multiple times within id vector.";
        throw std::domain_error(errmsg_stream__.str());
      } }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct check_duplicate_ids_functor__ {
void
operator()(const std::vector<int>& id, std::ostream* pstream__)  const 
{
return check_duplicate_ids(id, pstream__);
}
};
std::vector<int>
decimal2base(const int& decimal, const int& digits, const int& base,
             std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 454;
    validate_non_negative_index("base_rep", "digits", digits);
    std::vector<int> base_rep;
    base_rep = std::vector<int>(digits, std::numeric_limits<int>::min());
    
    int current;
    current = std::numeric_limits<int>::min();
    
    current_statement__ = 456;
    current = decimal;
    current_statement__ = 460;
    for (int i = 1; i <= digits; ++i) {
      current_statement__ = 457;
      assign(base_rep, cons_list(index_uni(i), nil_index_list()),
        modulus(current, base), "assigning variable base_rep");
      current_statement__ = 458;
      current = (current / base);}
    current_statement__ = 461;
    return base_rep;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct decimal2base_functor__ {
std::vector<int>
operator()(const int& decimal, const int& digits, const int& base,
           std::ostream* pstream__)  const 
{
return decimal2base(decimal, digits, base, pstream__);
}
};
int
power_int(const int& number, const int& power, std::ostream* pstream__) ;
int
power_int(const int& number, const int& power, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 464;
    if (logical_lt(power, 0)) {
      current_statement__ = 463;
      std::stringstream errmsg_stream__;
      errmsg_stream__ << "Cannot raise an integer to a negative power and expect an integer result.";
      throw std::domain_error(errmsg_stream__.str());
    } 
    current_statement__ = 467;
    if (logical_eq(power, 0)) {
      current_statement__ = 466;
      return 1;
    } else {
      current_statement__ = 465;
      return (number * power_int(number, (power - 1), pstream__));
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct power_int_functor__ {
int
operator()(const int& number, const int& power, std::ostream* pstream__)  const 
{
return power_int(number, power, pstream__);
}
};
int
cardinality_int(const std::vector<int>& elems, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 469;
    return rle_elem_count(sort_asc(elems), pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct cardinality_int_functor__ {
int
operator()(const std::vector<int>& elems, std::ostream* pstream__)  const 
{
return cardinality_int(elems, pstream__);
}
};
template <typename T0__>
int
cardinality_vector(const T0__& elems_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  const auto& elems = to_ref(elems_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 471;
    validate_non_negative_index("sort_asc_elems", "num_elements(elems)",
                                num_elements(elems));
    Eigen::Matrix<local_scalar_t__, -1, 1> sort_asc_elems;
    sort_asc_elems = Eigen::Matrix<local_scalar_t__, -1, 1>(num_elements(
                                                              elems));
    stan::math::fill(sort_asc_elems, DUMMY_VAR__);
    
    current_statement__ = 472;
    assign(sort_asc_elems, nil_index_list(), sort_asc(elems),
      "assigning variable sort_asc_elems");
    current_statement__ = 473;
    return rle_elem_count_vector(sort_asc_elems, pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct cardinality_vector_functor__ {
template <typename T0__>
int
operator()(const T0__& elems, std::ostream* pstream__)  const 
{
return cardinality_vector(elems, pstream__);
}
};
std::vector<int>
seq_int(const int& start, const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int N;
    N = std::numeric_limits<int>::min();
    
    current_statement__ = 475;
    N = ((end - start) + 1);
    current_statement__ = 476;
    validate_non_negative_index("seq", "N", N);
    std::vector<int> seq;
    seq = std::vector<int>(N, std::numeric_limits<int>::min());
    
    current_statement__ = 479;
    for (int i = 1; i <= N; ++i) {
      current_statement__ = 478;
      assign(seq, cons_list(index_uni(i), nil_index_list()),
        ((i + start) - 1), "assigning variable seq");}
    current_statement__ = 480;
    return seq;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct seq_int_functor__ {
std::vector<int>
operator()(const int& start, const int& end, std::ostream* pstream__)  const 
{
return seq_int(start, end, pstream__);
}
};
std::vector<int>
rep_each(const std::vector<int>& set, const std::vector<int>& each,
         std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int N;
    N = std::numeric_limits<int>::min();
    
    current_statement__ = 482;
    N = sum(each);
    current_statement__ = 483;
    validate_non_negative_index("replicated", "N", N);
    std::vector<int> replicated;
    replicated = std::vector<int>(N, std::numeric_limits<int>::min());
    
    int p;
    p = std::numeric_limits<int>::min();
    
    current_statement__ = 485;
    p = 1;
    current_statement__ = 489;
    for (int i = 1; i <= stan::math::size(set); ++i) {
      current_statement__ = 486;
      assign(replicated,
        cons_list(index_min_max(p, ((p + each[(i - 1)]) - 1)),
          nil_index_list()), rep_array(set[(i - 1)], each[(i - 1)]),
        "assigning variable replicated");
      current_statement__ = 487;
      p = (p + each[(i - 1)]);}
    current_statement__ = 490;
    return replicated;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct rep_each_functor__ {
std::vector<int>
operator()(const std::vector<int>& set, const std::vector<int>& each,
           std::ostream* pstream__)  const 
{
return rep_each(set, each, pstream__);
}
};
template <typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
log_diff_exp_abs(const T0__& la, const T1__& lb, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 492;
    return (0.5 *
             log_diff_exp(log_sum_exp((2 * la), (2 * lb)),
               ((stan::math::log(2) + la) + lb)));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct log_diff_exp_abs_functor__ {
template <typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
operator()(const T0__& la, const T1__& lb, std::ostream* pstream__)  const 
{
return log_diff_exp_abs(la, lb, pstream__);
}
};
template <typename T0__, typename T1__>
std::vector<int>
find_interval_slow(const T0__& x_arg__, const T1__& sorted_arg__,
                   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>>;
  const auto& x = to_ref(x_arg__);
  const auto& sorted = to_ref(sorted_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 494;
    validate_non_negative_index("res", "num_elements(x)", num_elements(x));
    std::vector<int> res;
    res = std::vector<int>(num_elements(x), std::numeric_limits<int>::min());
    
    current_statement__ = 498;
    for (int i = 1; i <= num_elements(x); ++i) {
      current_statement__ = 496;
      assign(res, cons_list(index_uni(i), nil_index_list()),
        rank(append_row(rep_vector(x[(i - 1)], 1), sorted), 1),
        "assigning variable res");}
    current_statement__ = 499;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct find_interval_slow_functor__ {
template <typename T0__, typename T1__>
std::vector<int>
operator()(const T0__& x, const T1__& sorted, std::ostream* pstream__)  const 
{
return find_interval_slow(x, sorted, pstream__);
}
};
template <typename T0__, typename T1__>
int
find_interval_elem(const T0__& x, const T1__& sorted_arg__,
                   const int& start_ind, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
          stan::value_type_t<T1__>>;
  const auto& sorted = to_ref(sorted_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int res;
    res = std::numeric_limits<int>::min();
    
    int N;
    N = std::numeric_limits<int>::min();
    
    int max_iter;
    max_iter = std::numeric_limits<int>::min();
    
    local_scalar_t__ left;
    left = DUMMY_VAR__;
    
    local_scalar_t__ right;
    right = DUMMY_VAR__;
    
    int left_ind;
    left_ind = std::numeric_limits<int>::min();
    
    int right_ind;
    right_ind = std::numeric_limits<int>::min();
    
    int iter;
    iter = std::numeric_limits<int>::min();
    
    current_statement__ = 509;
    N = num_elements(sorted);
    current_statement__ = 511;
    if (logical_eq(N, 0)) {
      current_statement__ = 510;
      return 0;
    } 
    current_statement__ = 512;
    left_ind = start_ind;
    current_statement__ = 513;
    right_ind = N;
    current_statement__ = 514;
    max_iter = (100 * N);
    current_statement__ = 515;
    left = (sorted[(left_ind - 1)] - x);
    current_statement__ = 516;
    right = (sorted[(right_ind - 1)] - x);
    current_statement__ = 518;
    if (logical_lte(0, left)) {
      current_statement__ = 517;
      return (left_ind - 1);
    } 
    current_statement__ = 520;
    if (logical_eq(0, right)) {
      current_statement__ = 519;
      return (N - 1);
    } 
    current_statement__ = 522;
    if (logical_gt(0, right)) {
      current_statement__ = 521;
      return N;
    } 
    current_statement__ = 523;
    iter = 1;
    current_statement__ = 540;
    while ((primitive_value(logical_gt((right_ind - left_ind), 1)) &&
           primitive_value(logical_neq(iter, max_iter)))) {
      int mid_ind;
      mid_ind = std::numeric_limits<int>::min();
      
      local_scalar_t__ mid;
      mid = DUMMY_VAR__;
      
      current_statement__ = 526;
      mid_ind = ((left_ind + right_ind) / 2);
      current_statement__ = 527;
      mid = (sorted[(mid_ind - 1)] - x);
      current_statement__ = 529;
      if (logical_eq(mid, 0)) {
        current_statement__ = 528;
        return (mid_ind - 1);
      } 
      current_statement__ = 533;
      if (logical_lt((left * mid), 0)) {
        current_statement__ = 530;
        right = mid;
        current_statement__ = 531;
        right_ind = mid_ind;
      } 
      current_statement__ = 537;
      if (logical_lt((right * mid), 0)) {
        current_statement__ = 534;
        left = mid;
        current_statement__ = 535;
        left_ind = mid_ind;
      } 
      current_statement__ = 538;
      iter = (iter + 1);
    }
    current_statement__ = 542;
    if (logical_eq(iter, max_iter)) {
      current_statement__ = 541;
      if (pstream__) {
        stan_print(pstream__, "Maximum number of iterations reached.");
        stan_print(pstream__, "\n");
      }
    } 
    current_statement__ = 543;
    return left_ind;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct find_interval_elem_functor__ {
template <typename T0__, typename T1__>
int
operator()(const T0__& x, const T1__& sorted, const int& start_ind,
           std::ostream* pstream__)  const 
{
return find_interval_elem(x, sorted, start_ind, pstream__);
}
};
template <typename T0__, typename T1__>
std::vector<int>
find_interval(const T0__& x_arg__, const T1__& sorted_arg__,
              std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>>;
  const auto& x = to_ref(x_arg__);
  const auto& sorted = to_ref(sorted_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 545;
    validate_non_negative_index("res", "num_elements(x)", num_elements(x));
    std::vector<int> res;
    res = std::vector<int>(num_elements(x), std::numeric_limits<int>::min());
    
    current_statement__ = 549;
    for (int i = 1; i <= num_elements(x); ++i) {
      current_statement__ = 547;
      assign(res, cons_list(index_uni(i), nil_index_list()),
        find_interval_elem(x[(i - 1)], sorted, 1, pstream__),
        "assigning variable res");}
    current_statement__ = 550;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct find_interval_functor__ {
template <typename T0__, typename T1__>
std::vector<int>
operator()(const T0__& x, const T1__& sorted, std::ostream* pstream__)  const 
{
return find_interval(x, sorted, pstream__);
}
};
template <typename T0__, typename T1__>
std::vector<int>
find_interval_asc(const T0__& x_arg__, const T1__& sorted_arg__,
                  std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>>;
  const auto& x = to_ref(x_arg__);
  const auto& sorted = to_ref(sorted_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 552;
    validate_non_negative_index("res", "num_elements(x)", num_elements(x));
    std::vector<int> res;
    res = std::vector<int>(num_elements(x), std::numeric_limits<int>::min());
    
    int last;
    last = std::numeric_limits<int>::min();
    
    current_statement__ = 555;
    last = 1;
    current_statement__ = 560;
    for (int i = 1; i <= num_elements(x); ++i) {
      current_statement__ = 556;
      assign(res, cons_list(index_uni(i), nil_index_list()),
        find_interval_elem(x[(i - 1)], sorted, last, pstream__),
        "assigning variable res");
      current_statement__ = 558;
      if (logical_gt(res[(i - 1)], 0)) {
        current_statement__ = 557;
        last = res[(i - 1)];
      } }
    current_statement__ = 561;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct find_interval_asc_functor__ {
template <typename T0__, typename T1__>
std::vector<int>
operator()(const T0__& x, const T1__& sorted, std::ostream* pstream__)  const 
{
return find_interval_asc(x, sorted, pstream__);
}
};
template <typename T1__, typename T3__>
std::vector<int>
find_interval_blocked(const std::vector<int>& vals_M, const T1__& vals_arg__,
                      const std::vector<int>& sorted_M,
                      const T3__& sorted_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T1__>,
          stan::value_type_t<T3__>>;
  const auto& vals = to_ref(vals_arg__);
  const auto& sorted = to_ref(sorted_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 563;
    validate_non_negative_index("res", "num_elements(vals)",
                                num_elements(vals));
    std::vector<int> res;
    res = std::vector<int>(num_elements(vals), std::numeric_limits<int>::min());
    
    int M;
    M = std::numeric_limits<int>::min();
    
    int v;
    v = std::numeric_limits<int>::min();
    
    int s;
    s = std::numeric_limits<int>::min();
    
    current_statement__ = 568;
    M = num_elements(vals_M);
    current_statement__ = 569;
    v = 1;
    current_statement__ = 570;
    s = 1;
    current_statement__ = 579;
    for (int m = 1; m <= M; ++m) {
      current_statement__ = 571;
      validate_non_negative_index("temp", "vals_M[m]", vals_M[(m - 1)]);
      std::vector<int> temp;
      temp = std::vector<int>(vals_M[(m - 1)], std::numeric_limits<int>::min());
      
      current_statement__ = 573;
      assign(temp, nil_index_list(),
        find_interval(segment(vals, v, vals_M[(m - 1)]),
          segment(sorted, s, sorted_M[(m - 1)]), pstream__),
        "assigning variable temp");
      current_statement__ = 575;
      for (int n = 1; n <= vals_M[(m - 1)]; ++n) {
        current_statement__ = 574;
        assign(res, cons_list(index_uni(((v + n) - 1)), nil_index_list()),
          temp[(n - 1)], "assigning variable res");}
      current_statement__ = 576;
      v = (v + vals_M[(m - 1)]);
      current_statement__ = 577;
      s = (s + sorted_M[(m - 1)]);}
    current_statement__ = 580;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct find_interval_blocked_functor__ {
template <typename T1__, typename T3__>
std::vector<int>
operator()(const std::vector<int>& vals_M, const T1__& vals,
           const std::vector<int>& sorted_M, const T3__& sorted,
           std::ostream* pstream__)  const 
{
return find_interval_blocked(vals_M, vals, sorted_M, sorted, pstream__);
}
};
int
count_elem(const std::vector<int>& test, const int& elem,
           std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int count;
    count = std::numeric_limits<int>::min();
    
    current_statement__ = 583;
    count = 0;
    current_statement__ = 586;
    for (int i = 1; i <= num_elements(test); ++i) {
      current_statement__ = 585;
      if (logical_eq(test[(i - 1)], elem)) {
        current_statement__ = 584;
        count = (count + 1);
      } }
    current_statement__ = 587;
    return count;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct count_elem_functor__ {
int
operator()(const std::vector<int>& test, const int& elem,
           std::ostream* pstream__)  const 
{
return count_elem(test, elem, pstream__);
}
};
std::vector<int>
count_elems(const std::vector<int>& test, const std::vector<int>& elems,
            std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 589;
    validate_non_negative_index("counts", "num_elements(elems)",
                                num_elements(elems));
    std::vector<int> counts;
    counts = std::vector<int>(num_elements(elems), std::numeric_limits<int>::min());
    
    current_statement__ = 592;
    for (int i = 1; i <= num_elements(elems); ++i) {
      current_statement__ = 591;
      assign(counts, cons_list(index_uni(i), nil_index_list()),
        count_elem(test, elems[(i - 1)], pstream__),
        "assigning variable counts");}
    current_statement__ = 593;
    return counts;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct count_elems_functor__ {
std::vector<int>
operator()(const std::vector<int>& test, const std::vector<int>& elems,
           std::ostream* pstream__)  const 
{
return count_elems(test, elems, pstream__);
}
};
std::vector<int>
which_elem(const std::vector<int>& test, const int& elem,
           std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 595;
    validate_non_negative_index("res", "count_elem(test, elem)",
                                count_elem(test, elem, pstream__));
    std::vector<int> res;
    res = std::vector<int>(count_elem(test, elem, pstream__), std::numeric_limits<int>::min());
    
    int ci;
    ci = std::numeric_limits<int>::min();
    
    current_statement__ = 598;
    ci = 1;
    current_statement__ = 603;
    for (int i = 1; i <= num_elements(test); ++i) {
      current_statement__ = 602;
      if (logical_eq(test[(i - 1)], elem)) {
        current_statement__ = 599;
        assign(res, cons_list(index_uni(ci), nil_index_list()), i,
          "assigning variable res");
        current_statement__ = 600;
        ci = (ci + 1);
      } }
    current_statement__ = 604;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct which_elem_functor__ {
std::vector<int>
operator()(const std::vector<int>& test, const int& elem,
           std::ostream* pstream__)  const 
{
return which_elem(test, elem, pstream__);
}
};
template <typename T0__, typename T1__>
int
floor_div_int(const T0__& fac, const T1__& div, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int count;
    count = std::numeric_limits<int>::min();
    
    current_statement__ = 608;
    if (logical_lt(fac, 0)) {
      current_statement__ = 607;
      std::stringstream errmsg_stream__;
      errmsg_stream__ << "floor_div_int only works for positive values.";
      throw std::domain_error(errmsg_stream__.str());
    } 
    current_statement__ = 609;
    count = 1;
    current_statement__ = 612;
    while (logical_lte((count * div), fac)) {
      current_statement__ = 610;
      count = (count + 1);
    }
    current_statement__ = 613;
    count = (count - 1);
    current_statement__ = 614;
    return count;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct floor_div_int_functor__ {
template <typename T0__, typename T1__>
int
operator()(const T0__& fac, const T1__& div, std::ostream* pstream__)  const 
{
return floor_div_int(fac, div, pstream__);
}
};
std::vector<int>
count_obs_event_free(const std::vector<int>& obs_timeRank, const int& ndose,
                     std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 616;
    validate_non_negative_index("dose_next_obs", "ndose", ndose);
    std::vector<int> dose_next_obs;
    dose_next_obs = std::vector<int>(ndose, std::numeric_limits<int>::min());
    
    int o;
    o = std::numeric_limits<int>::min();
    
    int O;
    O = std::numeric_limits<int>::min();
    
    current_statement__ = 620;
    assign(dose_next_obs, nil_index_list(), rep_array(0, ndose),
      "assigning variable dose_next_obs");
    current_statement__ = 621;
    o = 0;
    current_statement__ = 622;
    O = stan::math::size(obs_timeRank);
    current_statement__ = 625;
    while ((primitive_value(logical_lt(o, O)) && primitive_value(
           logical_eq(obs_timeRank[((o + 1) - 1)], 0)))) {
      current_statement__ = 623;
      o = (o + 1);
    }
    current_statement__ = 634;
    for (int i = 1; i <= ndose; ++i) {
      int count;
      count = std::numeric_limits<int>::min();
      
      current_statement__ = 627;
      count = 0;
      current_statement__ = 631;
      while ((primitive_value(logical_lt(o, O)) && primitive_value(
             logical_eq(obs_timeRank[((o + 1) - 1)], i)))) {
        current_statement__ = 628;
        o = (o + 1);
        current_statement__ = 629;
        count = (count + 1);
      }
      current_statement__ = 632;
      assign(dose_next_obs, cons_list(index_uni(i), nil_index_list()), count,
        "assigning variable dose_next_obs");}
    current_statement__ = 635;
    return dose_next_obs;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct count_obs_event_free_functor__ {
std::vector<int>
operator()(const std::vector<int>& obs_timeRank, const int& ndose,
           std::ostream* pstream__)  const 
{
return count_obs_event_free(obs_timeRank, ndose, pstream__);
}
};
std::vector<int>
count_obs_event_free_blocked(const std::vector<int>& M,
                             const std::vector<int>& obs_timeRank,
                             const std::vector<int>& ndose,
                             std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 637;
    validate_non_negative_index("dose_next_obs", "sum(ndose)", sum(ndose));
    std::vector<int> dose_next_obs;
    dose_next_obs = std::vector<int>(sum(ndose), std::numeric_limits<int>::min());
    
    int l;
    l = std::numeric_limits<int>::min();
    
    int ld;
    ld = std::numeric_limits<int>::min();
    
    current_statement__ = 641;
    assign(dose_next_obs, nil_index_list(), rep_array(0, sum(ndose)),
      "assigning variable dose_next_obs");
    current_statement__ = 642;
    l = 1;
    current_statement__ = 643;
    ld = 1;
    current_statement__ = 652;
    for (int i = 1; i <= stan::math::size(M); ++i) {
      int u;
      u = std::numeric_limits<int>::min();
      
      int ud;
      ud = std::numeric_limits<int>::min();
      
      current_statement__ = 646;
      u = ((l + M[(i - 1)]) - 1);
      current_statement__ = 647;
      ud = ((ld + ndose[(i - 1)]) - 1);
      current_statement__ = 648;
      assign(dose_next_obs,
        cons_list(index_min_max(ld, ud), nil_index_list()),
        count_obs_event_free(
          rvalue(obs_timeRank,
            cons_list(index_min_max(l, u), nil_index_list()), "obs_timeRank"),
          ndose[(i - 1)], pstream__), "assigning variable dose_next_obs");
      current_statement__ = 649;
      l = (u + 1);
      current_statement__ = 650;
      ld = (ud + 1);}
    current_statement__ = 653;
    return dose_next_obs;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct count_obs_event_free_blocked_functor__ {
std::vector<int>
operator()(const std::vector<int>& M, const std::vector<int>& obs_timeRank,
           const std::vector<int>& ndose, std::ostream* pstream__)  const 
{
return count_obs_event_free_blocked(M, obs_timeRank, ndose, pstream__);
}
};
std::vector<int>
subset_int(const std::vector<int>& cand, const std::vector<int>& ind_set,
           std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 655;
    validate_non_negative_index("out", "size(ind_set)",
                                stan::math::size(ind_set));
    std::vector<int> out;
    out = std::vector<int>(stan::math::size(ind_set), std::numeric_limits<int>::min());
    
    current_statement__ = 658;
    for (int i = 1; i <= stan::math::size(ind_set); ++i) {
      current_statement__ = 657;
      assign(out, cons_list(index_uni(i), nil_index_list()),
        cand[(ind_set[(i - 1)] - 1)], "assigning variable out");}
    current_statement__ = 659;
    return out;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct subset_int_functor__ {
std::vector<int>
operator()(const std::vector<int>& cand, const std::vector<int>& ind_set,
           std::ostream* pstream__)  const 
{
return subset_int(cand, ind_set, pstream__);
}
};
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
subset_vec(const T0__& cand_arg__, const std::vector<int>& ind_set,
           std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  const auto& cand = to_ref(cand_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 661;
    validate_non_negative_index("out", "size(ind_set)",
                                stan::math::size(ind_set));
    Eigen::Matrix<local_scalar_t__, -1, 1> out;
    out = Eigen::Matrix<local_scalar_t__, -1, 1>(stan::math::size(ind_set));
    stan::math::fill(out, DUMMY_VAR__);
    
    current_statement__ = 664;
    for (int i = 1; i <= stan::math::size(ind_set); ++i) {
      current_statement__ = 663;
      assign(out, cons_list(index_uni(i), nil_index_list()),
        cand[(ind_set[(i - 1)] - 1)], "assigning variable out");}
    current_statement__ = 665;
    return out;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct subset_vec_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
operator()(const T0__& cand, const std::vector<int>& ind_set,
           std::ostream* pstream__)  const 
{
return subset_vec(cand, ind_set, pstream__);
}
};
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
subset_matrix(const T0__& cand_arg__, const std::vector<int>& ind_set,
              std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  const auto& cand = to_ref(cand_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 667;
    validate_non_negative_index("out", "size(ind_set)",
                                stan::math::size(ind_set));
    current_statement__ = 668;
    validate_non_negative_index("out", "cols(cand)", cols(cand));
    Eigen::Matrix<local_scalar_t__, -1, -1> out;
    out = Eigen::Matrix<local_scalar_t__, -1, -1>(stan::math::size(ind_set), 
      cols(cand));
    stan::math::fill(out, DUMMY_VAR__);
    
    current_statement__ = 671;
    for (int i = 1; i <= stan::math::size(ind_set); ++i) {
      current_statement__ = 670;
      assign(out, cons_list(index_uni(i), nil_index_list()),
        rvalue(cand,
          cons_list(index_uni(ind_set[(i - 1)]), nil_index_list()), "cand"),
        "assigning variable out");}
    current_statement__ = 672;
    return out;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct subset_matrix_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
operator()(const T0__& cand, const std::vector<int>& ind_set,
           std::ostream* pstream__)  const 
{
return subset_matrix(cand, ind_set, pstream__);
}
};
void
check_ids(const std::vector<int>& id, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int cid;
    cid = std::numeric_limits<int>::min();
    
    current_statement__ = 674;
    cid = 0;
    int warned;
    warned = std::numeric_limits<int>::min();
    
    current_statement__ = 675;
    warned = 0;
    current_statement__ = 676;
    cid = 0;
    current_statement__ = 687;
    for (int n = 1; n <= num_elements(id); ++n) {
      current_statement__ = 685;
      if (logical_neq(id[(n - 1)], cid)) {
        current_statement__ = 683;
        if (logical_neq(id[(n - 1)], (cid + 1))) {
          current_statement__ = 680;
          if (logical_negation(warned)) {
            current_statement__ = 679;
            if (pstream__) {
              stan_print(pstream__, "WARNING: id vector not correctly sorted, i.e. not in range 1..J. Consider using the cid vector internally.");
              stan_print(pstream__, "\n");
            }
          } 
          current_statement__ = 681;
          warned = 1;
        } else {
          current_statement__ = 677;
          cid = (cid + 1);
        }
      } }
    current_statement__ = 689;
    if (logical_neq(max(id), cid)) {
      current_statement__ = 688;
      if (pstream__) {
        stan_print(pstream__, "WARNING: Last patient's id not equal to max(id).");
        stan_print(pstream__, "\n");
      }
    } 
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct check_ids_functor__ {
void
operator()(const std::vector<int>& id, std::ostream* pstream__)  const 
{
return check_ids(id, pstream__);
}
};
template <typename T0__, typename T1__>
void
check_addl_dosing(const T0__& dose_time_arg__, const T1__& dose_tau_arg__,
                  const std::vector<int>& dose_addl, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>>;
  const auto& dose_time = to_ref(dose_time_arg__);
  const auto& dose_tau = to_ref(dose_tau_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int D;
    D = std::numeric_limits<int>::min();
    
    current_statement__ = 691;
    D = num_elements(dose_time);
    current_statement__ = 695;
    for (int d = 2; d <= D; ++d) {
      current_statement__ = 693;
      if (logical_lt(dose_time[(d - 1)],
            (dose_time[((d - 1) - 1)] +
              (dose_tau[((d - 1) - 1)] * dose_addl[((d - 1) - 1)])))) {
        current_statement__ = 692;
        std::stringstream errmsg_stream__;
        errmsg_stream__ << "Forbidden overlapping dosing records found.";
        throw std::domain_error(errmsg_stream__.str());
      } }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct check_addl_dosing_functor__ {
template <typename T0__, typename T1__>
void
operator()(const T0__& dose_time, const T1__& dose_tau,
           const std::vector<int>& dose_addl, std::ostream* pstream__)  const 
{
return check_addl_dosing(dose_time, dose_tau, dose_addl, pstream__);
}
};
template <typename T1__, typename T2__>
void
check_addl_dosing_blocked(const std::vector<int>& dose_M,
                          const T1__& dose_time_arg__,
                          const T2__& dose_tau_arg__,
                          const std::vector<int>& dose_addl,
                          std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T1__>,
          stan::value_type_t<T2__>>;
  const auto& dose_time = to_ref(dose_time_arg__);
  const auto& dose_tau = to_ref(dose_tau_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int M;
    M = std::numeric_limits<int>::min();
    
    current_statement__ = 697;
    M = num_elements(dose_M);
    int b;
    b = std::numeric_limits<int>::min();
    
    current_statement__ = 698;
    b = 1;
    current_statement__ = 702;
    for (int m = 1; m <= M; ++m) {
      current_statement__ = 699;
      check_addl_dosing(segment(dose_time, b, dose_M[(m - 1)]),
        segment(dose_tau, b, dose_M[(m - 1)]),
        segment(dose_addl, b, dose_M[(m - 1)]), pstream__);
      current_statement__ = 700;
      b = (b + dose_M[(m - 1)]);}
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct check_addl_dosing_blocked_functor__ {
template <typename T1__, typename T2__>
void
operator()(const std::vector<int>& dose_M, const T1__& dose_time,
           const T2__& dose_tau, const std::vector<int>& dose_addl,
           std::ostream* pstream__)  const 
{
return check_addl_dosing_blocked(dose_M, dose_time, dose_tau, dose_addl,
         pstream__);
}
};
template <bool propto__, typename T0__, typename T2__, typename T3__>
stan::promote_args_t<T0__, T2__,
T3__>
tau_prior_lpdf(const T0__& tau, const int& dist, const T2__& a,
               const T3__& b, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T2__, T3__>;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 712;
    if (logical_eq(dist, 0)) {
      current_statement__ = 710;
      return std_normal_lpdf<false>(tau);
    } else {
      current_statement__ = 709;
      if (logical_eq(dist, 1)) {
        current_statement__ = 707;
        return lognormal_lpdf<false>(tau, a, b);
      } else {
        current_statement__ = 706;
        if (logical_eq(dist, 2)) {
          current_statement__ = 704;
          return normal_lpdf<false>(tau, a, b);
        } 
      }
    }
    current_statement__ = 713;
    std::stringstream errmsg_stream__;
    errmsg_stream__ << "Invalid distribution for tau.";
    throw std::domain_error(errmsg_stream__.str());
    current_statement__ = 714;
    return 0.0;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct tau_prior_lpdf_functor__ {
template <bool propto__, typename T0__, typename T2__, typename T3__>
stan::promote_args_t<T0__, T2__,
T3__>
operator()(const T0__& tau, const int& dist, const T2__& a, const T3__& b,
           std::ostream* pstream__)  const 
{
return tau_prior_lpdf<propto__>(tau, dist, a, b, pstream__);
}
};
template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
T1__>, -1, -1>
bvn_cholesky_lower(const T0__& tau_arg__, const T1__& rho,
                   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          T1__>;
  const auto& tau = to_ref(tau_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 716;
    return stan::math::to_matrix(
        std::vector<Eigen::Matrix<local_scalar_t__, 1, -1>>{
        (Eigen::Matrix<local_scalar_t__,1,-1>(2) << tau[(1 - 1)],
        0.0).finished(), (Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
        (tau[(2 - 1)] * rho),
        (tau[(2 - 1)] * stan::math::sqrt((1.0 - pow(rho, 2))))).finished()});
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct bvn_cholesky_lower_functor__ {
template <typename T0__, typename T1__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
T1__>, -1, -1>
operator()(const T0__& tau, const T1__& rho, std::ostream* pstream__)  const 
{
return bvn_cholesky_lower(tau, rho, pstream__);
}
};
template <typename T2__, typename T4__, typename T5__, typename T6__>
Eigen::Matrix<stan::promote_args_t<T2__, stan::value_type_t<T4__>, T5__,
stan::value_type_t<T6__>>, -1, 1>
blrm_logit_fast(const std::vector<int>& obs_gidx, const std::vector<int>& n,
                const std::vector<Eigen::Matrix<T2__, -1, -1>>& X_comp,
                const std::vector<std::vector<int>>& finite_cov,
                const T4__& X_inter_arg__,
                const std::vector<Eigen::Matrix<T5__, -1, 1>>& beta,
                const T6__& eta_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T2__,
          stan::value_type_t<T4__>,
          T5__,
          stan::value_type_t<T6__>>;
  const auto& X_inter = to_ref(X_inter_arg__);
  const auto& eta = to_ref(eta_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int num_obs;
    num_obs = std::numeric_limits<int>::min();
    
    current_statement__ = 718;
    num_obs = stan::math::size(obs_gidx);
    int num_comp;
    num_comp = std::numeric_limits<int>::min();
    
    current_statement__ = 719;
    num_comp = stan::math::size(X_comp);
    int num_inter;
    num_inter = std::numeric_limits<int>::min();
    
    current_statement__ = 720;
    num_inter = cols(X_inter);
    current_statement__ = 721;
    validate_non_negative_index("mu", "num_obs", num_obs);
    Eigen::Matrix<local_scalar_t__, -1, 1> mu;
    mu = Eigen::Matrix<local_scalar_t__, -1, 1>(num_obs);
    stan::math::fill(mu, DUMMY_VAR__);
    
    current_statement__ = 739;
    for (int i = 1; i <= num_obs; ++i) {
      int idx;
      idx = std::numeric_limits<int>::min();
      
      current_statement__ = 723;
      idx = obs_gidx[(i - 1)];
      local_scalar_t__ log_p0_nr;
      log_p0_nr = DUMMY_VAR__;
      
      current_statement__ = 724;
      log_p0_nr = 0.0;
      current_statement__ = 734;
      if (logical_eq(n[(idx - 1)], 0)) {
        current_statement__ = 732;
        assign(mu, cons_list(index_uni(i), nil_index_list()), 0.0,
          "assigning variable mu");
      } else {
        current_statement__ = 729;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 727;
          if (finite_cov[(j - 1)][(idx - 1)]) {
            current_statement__ = 725;
            log_p0_nr = (log_p0_nr +
                          log_inv_logit(
                            multiply(
                              multiply(-1.0,
                                rvalue(X_comp,
                                  cons_list(index_uni(j),
                                    cons_list(index_uni(idx),
                                      nil_index_list())), "X_comp")),
                              beta[(j - 1)])));
          } }
        current_statement__ = 730;
        assign(mu, cons_list(index_uni(i), nil_index_list()),
          (log1m_exp(log_p0_nr) - log_p0_nr), "assigning variable mu");
      }
      current_statement__ = 737;
      if (logical_gt(num_inter, 0)) {
        current_statement__ = 735;
        assign(mu, cons_list(index_uni(i), nil_index_list()),
          (mu[(i - 1)] +
            multiply(
              rvalue(X_inter, cons_list(index_uni(idx), nil_index_list()),
                "X_inter"), eta)), "assigning variable mu");
      } }
    current_statement__ = 740;
    return mu;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct blrm_logit_fast_functor__ {
template <typename T2__, typename T4__, typename T5__, typename T6__>
Eigen::Matrix<stan::promote_args_t<T2__, stan::value_type_t<T4__>, T5__,
stan::value_type_t<T6__>>, -1, 1>
operator()(const std::vector<int>& obs_gidx, const std::vector<int>& n,
           const std::vector<Eigen::Matrix<T2__, -1, -1>>& X_comp,
           const std::vector<std::vector<int>>& finite_cov,
           const T4__& X_inter,
           const std::vector<Eigen::Matrix<T5__, -1, 1>>& beta,
           const T6__& eta, std::ostream* pstream__)  const 
{
return blrm_logit_fast(obs_gidx, n, X_comp, finite_cov, X_inter, beta, eta,
         pstream__);
}
};
template <bool propto__, typename T3__, typename T5__, typename T6__,
typename T7__>
stan::promote_args_t<T3__, stan::value_type_t<T5__>, T6__,
stan::value_type_t<T7__>>
blrm_lpmf(const std::vector<int>& r, const std::vector<int>& obs_gidx,
          const std::vector<int>& n,
          const std::vector<Eigen::Matrix<T3__, -1, -1>>& X_comp,
          const std::vector<std::vector<int>>& finite_cov,
          const T5__& X_inter_arg__,
          const std::vector<Eigen::Matrix<T6__, -1, 1>>& beta,
          const T7__& eta_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
          stan::value_type_t<T5__>,
          T6__,
          stan::value_type_t<T7__>>;
  const auto& X_inter = to_ref(X_inter_arg__);
  const auto& eta = to_ref(eta_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int num_obs;
    num_obs = std::numeric_limits<int>::min();
    
    current_statement__ = 742;
    num_obs = stan::math::size(obs_gidx);
    current_statement__ = 743;
    validate_non_negative_index("r_obs", "num_obs", num_obs);
    std::vector<int> r_obs;
    r_obs = std::vector<int>(num_obs, std::numeric_limits<int>::min());
    
    current_statement__ = 745;
    validate_non_negative_index("n_obs", "num_obs", num_obs);
    std::vector<int> n_obs;
    n_obs = std::vector<int>(num_obs, std::numeric_limits<int>::min());
    
    current_statement__ = 750;
    for (int i = 1; i <= num_obs; ++i) {
      current_statement__ = 747;
      assign(r_obs, cons_list(index_uni(i), nil_index_list()),
        r[(obs_gidx[(i - 1)] - 1)], "assigning variable r_obs");
      current_statement__ = 748;
      assign(n_obs, cons_list(index_uni(i), nil_index_list()),
        n[(obs_gidx[(i - 1)] - 1)], "assigning variable n_obs");}
    current_statement__ = 751;
    return binomial_logit_lpmf<false>(r_obs, n_obs,
             blrm_logit_fast(obs_gidx, n, X_comp, finite_cov, X_inter, beta,
               eta, pstream__));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct blrm_lpmf_functor__ {
template <bool propto__, typename T3__, typename T5__, typename T6__,
typename T7__>
stan::promote_args_t<T3__, stan::value_type_t<T5__>, T6__,
stan::value_type_t<T7__>>
operator()(const std::vector<int>& r, const std::vector<int>& obs_gidx,
           const std::vector<int>& n,
           const std::vector<Eigen::Matrix<T3__, -1, -1>>& X_comp,
           const std::vector<std::vector<int>>& finite_cov,
           const T5__& X_inter,
           const std::vector<Eigen::Matrix<T6__, -1, 1>>& beta,
           const T7__& eta, std::ostream* pstream__)  const 
{
return blrm_lpmf<propto__>(r, obs_gidx, n, X_comp, finite_cov, X_inter, beta,
         eta, pstream__);
}
};
template <typename T3__, typename T5__, typename T6__, typename T7__>
stan::promote_args_t<T3__, stan::value_type_t<T5__>, T6__,
stan::value_type_t<T7__>>
blrm_lupmf_comp(const std::vector<int>& r, const std::vector<int>& obs_gidx,
                const std::vector<int>& n,
                const std::vector<Eigen::Matrix<T3__, -1, -1>>& X_comp,
                const std::vector<std::vector<int>>& finite_cov,
                const T5__& X_inter_arg__,
                const std::vector<Eigen::Matrix<T6__, -1, 1>>& beta,
                const T7__& eta_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
          stan::value_type_t<T5__>,
          T6__,
          stan::value_type_t<T7__>>;
  const auto& X_inter = to_ref(X_inter_arg__);
  const auto& eta = to_ref(eta_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int num_obs;
    num_obs = std::numeric_limits<int>::min();
    
    current_statement__ = 753;
    num_obs = stan::math::size(obs_gidx);
    current_statement__ = 754;
    validate_non_negative_index("r_obs", "num_obs", num_obs);
    std::vector<int> r_obs;
    r_obs = std::vector<int>(num_obs, std::numeric_limits<int>::min());
    
    current_statement__ = 756;
    validate_non_negative_index("nr_obs", "num_obs", num_obs);
    std::vector<int> nr_obs;
    nr_obs = std::vector<int>(num_obs, std::numeric_limits<int>::min());
    
    current_statement__ = 758;
    validate_non_negative_index("theta", "num_obs", num_obs);
    Eigen::Matrix<local_scalar_t__, -1, 1> theta;
    theta = Eigen::Matrix<local_scalar_t__, -1, 1>(num_obs);
    stan::math::fill(theta, DUMMY_VAR__);
    
    current_statement__ = 759;
    assign(theta, nil_index_list(),
      blrm_logit_fast(obs_gidx, n, X_comp, finite_cov, X_inter, beta,
        eta, pstream__), "assigning variable theta");
    current_statement__ = 760;
    validate_non_negative_index("log_pi", "num_obs", num_obs);
    Eigen::Matrix<local_scalar_t__, -1, 1> log_pi;
    log_pi = Eigen::Matrix<local_scalar_t__, -1, 1>(num_obs);
    stan::math::fill(log_pi, DUMMY_VAR__);
    
    current_statement__ = 761;
    assign(log_pi, nil_index_list(), log_inv_logit(theta),
      "assigning variable log_pi");
    current_statement__ = 762;
    validate_non_negative_index("log_inv_pi", "num_obs", num_obs);
    Eigen::Matrix<local_scalar_t__, -1, 1> log_inv_pi;
    log_inv_pi = Eigen::Matrix<local_scalar_t__, -1, 1>(num_obs);
    stan::math::fill(log_inv_pi, DUMMY_VAR__);
    
    current_statement__ = 763;
    assign(log_inv_pi, nil_index_list(),
      log_inv_logit(multiply(-1.0, theta)), "assigning variable log_inv_pi");
    current_statement__ = 767;
    for (int i = 1; i <= num_obs; ++i) {
      current_statement__ = 764;
      assign(r_obs, cons_list(index_uni(i), nil_index_list()),
        r[(obs_gidx[(i - 1)] - 1)], "assigning variable r_obs");
      current_statement__ = 765;
      assign(nr_obs, cons_list(index_uni(i), nil_index_list()),
        (n[(obs_gidx[(i - 1)] - 1)] - r_obs[(i - 1)]),
        "assigning variable nr_obs");}
    current_statement__ = 768;
    return (dot_product(to_vector(r_obs), log_pi) +
             dot_product(to_vector(nr_obs), log_inv_pi));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct blrm_lupmf_comp_functor__ {
template <typename T3__, typename T5__, typename T6__, typename T7__>
stan::promote_args_t<T3__, stan::value_type_t<T5__>, T6__,
stan::value_type_t<T7__>>
operator()(const std::vector<int>& r, const std::vector<int>& obs_gidx,
           const std::vector<int>& n,
           const std::vector<Eigen::Matrix<T3__, -1, -1>>& X_comp,
           const std::vector<std::vector<int>>& finite_cov,
           const T5__& X_inter,
           const std::vector<Eigen::Matrix<T6__, -1, 1>>& beta,
           const T7__& eta, std::ostream* pstream__)  const 
{
return blrm_lupmf_comp(r, obs_gidx, n, X_comp, finite_cov, X_inter, beta,
         eta, pstream__);
}
};
template <typename T5__, typename T7__, typename T8__, typename T10__>
Eigen::Matrix<stan::promote_args_t<T5__, stan::value_type_t<T7__>, T8__,
T10__>, -1, 1>
blrm_mix_lpmf_comp(const int& g, const int& num_groups,
                   const std::vector<int>& obs_gidx,
                   const std::vector<int>& r, const std::vector<int>& n,
                   const std::vector<Eigen::Matrix<T5__, -1, -1>>& X_comp,
                   const std::vector<std::vector<int>>& finite_cov,
                   const T7__& X_inter_arg__,
                   const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& beta,
                   const std::vector<std::vector<int>>& mix_idx_beta,
                   const std::vector<Eigen::Matrix<T10__, -1, 1>>& eta,
                   const std::vector<std::vector<int>>& mix_idx_eta,
                   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T5__,
          stan::value_type_t<T7__>,
          T8__,
          T10__>;
  const auto& X_inter = to_ref(X_inter_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int num_mix_comp;
    num_mix_comp = std::numeric_limits<int>::min();
    
    current_statement__ = 770;
    num_mix_comp = stan::math::size(mix_idx_beta);
    int num_comp;
    num_comp = std::numeric_limits<int>::min();
    
    current_statement__ = 771;
    num_comp = dims(mix_idx_beta)[(2 - 1)];
    int num_inter;
    num_inter = std::numeric_limits<int>::min();
    
    current_statement__ = 772;
    num_inter = dims(mix_idx_eta)[(2 - 1)];
    current_statement__ = 773;
    validate_non_negative_index("mix_lpmf", "num_mix_comp", num_mix_comp);
    Eigen::Matrix<local_scalar_t__, -1, 1> mix_lpmf;
    mix_lpmf = Eigen::Matrix<local_scalar_t__, -1, 1>(num_mix_comp);
    stan::math::fill(mix_lpmf, DUMMY_VAR__);
    
    current_statement__ = 776;
    if (logical_eq(num_elements(r), 0)) {
      current_statement__ = 775;
      return rep_vector(0.0, num_mix_comp);
    } 
    current_statement__ = 791;
    for (int m = 1; m <= num_mix_comp; ++m) {
      current_statement__ = 777;
      validate_non_negative_index("ind_beta", "num_comp", num_comp);
      std::vector<int> ind_beta;
      ind_beta = std::vector<int>(num_comp, std::numeric_limits<int>::min());
      
      current_statement__ = 778;
      assign(ind_beta, nil_index_list(), mix_idx_beta[(m - 1)],
        "assigning variable ind_beta");
      current_statement__ = 779;
      validate_non_negative_index("ind_eta", "num_inter", num_inter);
      std::vector<int> ind_eta;
      ind_eta = std::vector<int>(num_inter, std::numeric_limits<int>::min());
      
      current_statement__ = 780;
      assign(ind_eta, nil_index_list(), mix_idx_eta[(m - 1)],
        "assigning variable ind_eta");
      current_statement__ = 781;
      validate_non_negative_index("beta_mix_config", "num_comp", num_comp);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> beta_mix_config;
      beta_mix_config = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(num_comp, Eigen::Matrix<local_scalar_t__, -1, 1>(2));
      stan::math::fill(beta_mix_config, DUMMY_VAR__);
      
      current_statement__ = 783;
      validate_non_negative_index("eta_mix_config", "num_inter", num_inter);
      Eigen::Matrix<local_scalar_t__, -1, 1> eta_mix_config;
      eta_mix_config = Eigen::Matrix<local_scalar_t__, -1, 1>(num_inter);
      stan::math::fill(eta_mix_config, DUMMY_VAR__);
      
      current_statement__ = 786;
      for (int i = 1; i <= num_comp; ++i) {
        current_statement__ = 785;
        assign(beta_mix_config, cons_list(index_uni(i), nil_index_list()),
          beta[((logical_eq(ind_beta[(i - 1)], 1) ? g : (g + num_groups)) -
                 1)][(i - 1)], "assigning variable beta_mix_config");}
      current_statement__ = 788;
      for (int i = 1; i <= num_inter; ++i) {
        current_statement__ = 787;
        assign(eta_mix_config, cons_list(index_uni(i), nil_index_list()),
          eta[((logical_eq(ind_eta[(i - 1)], 1) ? g : (g + num_groups)) - 1)][
          (i - 1)], "assigning variable eta_mix_config");}
      current_statement__ = 789;
      assign(mix_lpmf, cons_list(index_uni(m), nil_index_list()),
        blrm_lpmf<false>(r, obs_gidx, n, X_comp, finite_cov, X_inter,
          beta_mix_config, eta_mix_config, pstream__),
        "assigning variable mix_lpmf");}
    current_statement__ = 792;
    return mix_lpmf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct blrm_mix_lpmf_comp_functor__ {
template <typename T5__, typename T7__, typename T8__, typename T10__>
Eigen::Matrix<stan::promote_args_t<T5__, stan::value_type_t<T7__>, T8__,
T10__>, -1, 1>
operator()(const int& g, const int& num_groups,
           const std::vector<int>& obs_gidx, const std::vector<int>& r,
           const std::vector<int>& n,
           const std::vector<Eigen::Matrix<T5__, -1, -1>>& X_comp,
           const std::vector<std::vector<int>>& finite_cov,
           const T7__& X_inter,
           const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& beta,
           const std::vector<std::vector<int>>& mix_idx_beta,
           const std::vector<Eigen::Matrix<T10__, -1, 1>>& eta,
           const std::vector<std::vector<int>>& mix_idx_eta,
           std::ostream* pstream__)  const 
{
return blrm_mix_lpmf_comp(g, num_groups, obs_gidx, r, n, X_comp, finite_cov,
         X_inter, beta, mix_idx_beta, eta, mix_idx_eta, pstream__);
}
};
template <typename T5__, typename T7__, typename T8__, typename T10__>
Eigen::Matrix<stan::promote_args_t<T5__, stan::value_type_t<T7__>, T8__,
T10__>, -1, 1>
blrm_mix_lupmf_comp(const int& g, const int& num_groups,
                    const std::vector<int>& obs_gidx,
                    const std::vector<int>& r, const std::vector<int>& n,
                    const std::vector<Eigen::Matrix<T5__, -1, -1>>& X_comp,
                    const std::vector<std::vector<int>>& finite_cov,
                    const T7__& X_inter_arg__,
                    const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& beta,
                    const std::vector<std::vector<int>>& mix_idx_beta,
                    const std::vector<Eigen::Matrix<T10__, -1, 1>>& eta,
                    const std::vector<std::vector<int>>& mix_idx_eta,
                    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T5__,
          stan::value_type_t<T7__>,
          T8__,
          T10__>;
  const auto& X_inter = to_ref(X_inter_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int num_mix_comp;
    num_mix_comp = std::numeric_limits<int>::min();
    
    current_statement__ = 794;
    num_mix_comp = stan::math::size(mix_idx_beta);
    int num_comp;
    num_comp = std::numeric_limits<int>::min();
    
    current_statement__ = 795;
    num_comp = dims(mix_idx_beta)[(2 - 1)];
    int num_inter;
    num_inter = std::numeric_limits<int>::min();
    
    current_statement__ = 796;
    num_inter = dims(mix_idx_eta)[(2 - 1)];
    current_statement__ = 797;
    validate_non_negative_index("mix_ll", "num_mix_comp", num_mix_comp);
    Eigen::Matrix<local_scalar_t__, -1, 1> mix_ll;
    mix_ll = Eigen::Matrix<local_scalar_t__, -1, 1>(num_mix_comp);
    stan::math::fill(mix_ll, DUMMY_VAR__);
    
    current_statement__ = 800;
    if (logical_eq(num_elements(r), 0)) {
      current_statement__ = 799;
      return rep_vector(0.0, num_mix_comp);
    } 
    current_statement__ = 815;
    for (int m = 1; m <= num_mix_comp; ++m) {
      current_statement__ = 801;
      validate_non_negative_index("ind_beta", "num_comp", num_comp);
      std::vector<int> ind_beta;
      ind_beta = std::vector<int>(num_comp, std::numeric_limits<int>::min());
      
      current_statement__ = 802;
      assign(ind_beta, nil_index_list(), mix_idx_beta[(m - 1)],
        "assigning variable ind_beta");
      current_statement__ = 803;
      validate_non_negative_index("ind_eta", "num_inter", num_inter);
      std::vector<int> ind_eta;
      ind_eta = std::vector<int>(num_inter, std::numeric_limits<int>::min());
      
      current_statement__ = 804;
      assign(ind_eta, nil_index_list(), mix_idx_eta[(m - 1)],
        "assigning variable ind_eta");
      current_statement__ = 805;
      validate_non_negative_index("beta_mix_config", "num_comp", num_comp);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> beta_mix_config;
      beta_mix_config = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(num_comp, Eigen::Matrix<local_scalar_t__, -1, 1>(2));
      stan::math::fill(beta_mix_config, DUMMY_VAR__);
      
      current_statement__ = 807;
      validate_non_negative_index("eta_mix_config", "num_inter", num_inter);
      Eigen::Matrix<local_scalar_t__, -1, 1> eta_mix_config;
      eta_mix_config = Eigen::Matrix<local_scalar_t__, -1, 1>(num_inter);
      stan::math::fill(eta_mix_config, DUMMY_VAR__);
      
      current_statement__ = 810;
      for (int i = 1; i <= num_comp; ++i) {
        current_statement__ = 809;
        assign(beta_mix_config, cons_list(index_uni(i), nil_index_list()),
          beta[((logical_eq(ind_beta[(i - 1)], 1) ? g : (g + num_groups)) -
                 1)][(i - 1)], "assigning variable beta_mix_config");}
      current_statement__ = 812;
      for (int i = 1; i <= num_inter; ++i) {
        current_statement__ = 811;
        assign(eta_mix_config, cons_list(index_uni(i), nil_index_list()),
          eta[((logical_eq(ind_eta[(i - 1)], 1) ? g : (g + num_groups)) - 1)][
          (i - 1)], "assigning variable eta_mix_config");}
      current_statement__ = 813;
      assign(mix_ll, cons_list(index_uni(m), nil_index_list()),
        blrm_lupmf_comp(r, obs_gidx, n, X_comp, finite_cov, X_inter,
          beta_mix_config, eta_mix_config, pstream__),
        "assigning variable mix_ll");}
    current_statement__ = 816;
    return mix_ll;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct blrm_mix_lupmf_comp_functor__ {
template <typename T5__, typename T7__, typename T8__, typename T10__>
Eigen::Matrix<stan::promote_args_t<T5__, stan::value_type_t<T7__>, T8__,
T10__>, -1, 1>
operator()(const int& g, const int& num_groups,
           const std::vector<int>& obs_gidx, const std::vector<int>& r,
           const std::vector<int>& n,
           const std::vector<Eigen::Matrix<T5__, -1, -1>>& X_comp,
           const std::vector<std::vector<int>>& finite_cov,
           const T7__& X_inter,
           const std::vector<std::vector<Eigen::Matrix<T8__, -1, 1>>>& beta,
           const std::vector<std::vector<int>>& mix_idx_beta,
           const std::vector<Eigen::Matrix<T10__, -1, 1>>& eta,
           const std::vector<std::vector<int>>& mix_idx_eta,
           std::ostream* pstream__)  const 
{
return blrm_mix_lupmf_comp(g, num_groups, obs_gidx, r, n, X_comp, finite_cov,
         X_inter, beta, mix_idx_beta, eta, mix_idx_eta, pstream__);
}
};
#include <stan_meta_header.hpp>
class model_blrm_exnex final : public model_base_crtp<model_blrm_exnex> {
private:
  int num_obs;
  std::vector<int> r;
  std::vector<int> nr;
  int num_comp;
  std::vector<Eigen::Matrix<double, -1, -1>> X_comp;
  int num_inter;
  Eigen::Matrix<double, -1, -1> X_inter;
  std::vector<int> group;
  std::vector<int> stratum;
  int num_groups;
  int num_strata;
  std::vector<int> group_stratum_cid;
  std::vector<int> prior_is_EXNEX_comp;
  std::vector<int> prior_is_EXNEX_inter;
  Eigen::Matrix<double, -1, -1> prior_EX_prob_comp;
  Eigen::Matrix<double, -1, -1> prior_EX_prob_inter;
  std::vector<Eigen::Matrix<double, -1, 1>> prior_EX_mu_mean_comp;
  std::vector<Eigen::Matrix<double, -1, 1>> prior_EX_mu_sd_comp;
  double prior_EX_corr_mu_comp;
  std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> prior_EX_tau_mean_comp;
  std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> prior_EX_tau_sd_comp;
  std::vector<double> prior_EX_corr_eta_comp;
  Eigen::Matrix<double, -1, 1> prior_EX_mu_mean_inter;
  Eigen::Matrix<double, -1, 1> prior_EX_mu_sd_inter;
  std::vector<Eigen::Matrix<double, -1, 1>> prior_EX_tau_mean_inter;
  std::vector<Eigen::Matrix<double, -1, 1>> prior_EX_tau_sd_inter;
  double prior_EX_corr_eta_inter;
  std::vector<Eigen::Matrix<double, -1, 1>> prior_NEX_mu_mean_comp;
  std::vector<Eigen::Matrix<double, -1, 1>> prior_NEX_mu_sd_comp;
  Eigen::Matrix<double, -1, 1> prior_NEX_mu_mean_inter;
  Eigen::Matrix<double, -1, 1> prior_NEX_mu_sd_inter;
  int prior_tau_dist;
  int prior_PD;
  std::vector<int> n;
  std::vector<std::vector<int>> finite_cov;
  int num_EXNEX_comp;
  int num_EXNEX_inter;
  int num_mix_dim;
  int num_mix_comp;
  std::vector<std::vector<int>> mix_is_EX_beta;
  std::vector<std::vector<int>> mix_is_EX_eta;
  std::vector<std::vector<int>> mix_idx_beta;
  std::vector<std::vector<int>> mix_idx_eta;
  std::vector<int> num_obs_group;
  std::vector<int> num_cases_group;
  std::vector<std::vector<int>> group_obs_idx;
  std::vector<Eigen::Matrix<double, -1, 1>> mix_log_weight;
  Eigen::Matrix<double, -1, 1> log_normfactor_group;
  int log_beta_raw_1dim__;
  int eta_raw_1dim__;
  int beta_1dim__;
  int eta_1dim__;
 
public:
  ~model_blrm_exnex() { }
  
  inline std::string model_name() const final { return "model_blrm_exnex"; }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.26.1-4-gd72b68b7-dirty", "stancflags = "};
  }
  
  
  model_blrm_exnex(stan::io::var_context& context__,
                   unsigned int random_seed__ = 0,
                   std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "model_blrm_exnex_namespace::model_blrm_exnex";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 138;
      context__.validate_dims("data initialization","num_obs","int",
          context__.to_vec());
      num_obs = std::numeric_limits<int>::min();
      
      current_statement__ = 138;
      num_obs = context__.vals_i("num_obs")[(1 - 1)];
      current_statement__ = 138;
      current_statement__ = 138;
      check_greater_or_equal(function__, "num_obs", num_obs, 0);
      current_statement__ = 139;
      validate_non_negative_index("r", "num_obs", num_obs);
      current_statement__ = 140;
      context__.validate_dims("data initialization","r","int",
          context__.to_vec(num_obs));
      r = std::vector<int>(num_obs, std::numeric_limits<int>::min());
      
      current_statement__ = 140;
      assign(r, nil_index_list(), context__.vals_i("r"),
        "assigning variable r");
      current_statement__ = 140;
      for (int sym1__ = 1; sym1__ <= num_obs; ++sym1__) {
        current_statement__ = 140;
        current_statement__ = 140;
        check_greater_or_equal(function__, "r[sym1__]", r[(sym1__ - 1)], 0);}
      current_statement__ = 141;
      validate_non_negative_index("nr", "num_obs", num_obs);
      current_statement__ = 142;
      context__.validate_dims("data initialization","nr","int",
          context__.to_vec(num_obs));
      nr = std::vector<int>(num_obs, std::numeric_limits<int>::min());
      
      current_statement__ = 142;
      assign(nr, nil_index_list(), context__.vals_i("nr"),
        "assigning variable nr");
      current_statement__ = 142;
      for (int sym1__ = 1; sym1__ <= num_obs; ++sym1__) {
        current_statement__ = 142;
        current_statement__ = 142;
        check_greater_or_equal(function__, "nr[sym1__]", nr[(sym1__ - 1)], 0);
      }
      current_statement__ = 143;
      context__.validate_dims("data initialization","num_comp","int",
          context__.to_vec());
      num_comp = std::numeric_limits<int>::min();
      
      current_statement__ = 143;
      num_comp = context__.vals_i("num_comp")[(1 - 1)];
      current_statement__ = 143;
      current_statement__ = 143;
      check_greater_or_equal(function__, "num_comp", num_comp, 1);
      current_statement__ = 144;
      validate_non_negative_index("X_comp", "num_comp", num_comp);
      current_statement__ = 145;
      validate_non_negative_index("X_comp", "num_obs", num_obs);
      current_statement__ = 146;
      context__.validate_dims("data initialization","X_comp","double",
          context__.to_vec(num_comp, num_obs, 2));
      X_comp = std::vector<Eigen::Matrix<double, -1, -1>>(num_comp, Eigen::Matrix<double, -1, -1>(num_obs, 2));
      stan::math::fill(X_comp, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> X_comp_flat__;
        current_statement__ = 146;
        assign(X_comp_flat__, nil_index_list(), context__.vals_r("X_comp"),
          "assigning variable X_comp_flat__");
        current_statement__ = 146;
        pos__ = 1;
        current_statement__ = 146;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 146;
          for (int sym2__ = 1; sym2__ <= num_obs; ++sym2__) {
            current_statement__ = 146;
            for (int sym3__ = 1; sym3__ <= num_comp; ++sym3__) {
              current_statement__ = 146;
              assign(X_comp,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                X_comp_flat__[(pos__ - 1)], "assigning variable X_comp");
              current_statement__ = 146;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 147;
      context__.validate_dims("data initialization","num_inter","int",
          context__.to_vec());
      num_inter = std::numeric_limits<int>::min();
      
      current_statement__ = 147;
      num_inter = context__.vals_i("num_inter")[(1 - 1)];
      current_statement__ = 147;
      current_statement__ = 147;
      check_greater_or_equal(function__, "num_inter", num_inter, 0);
      current_statement__ = 148;
      validate_non_negative_index("X_inter", "num_obs", num_obs);
      current_statement__ = 149;
      validate_non_negative_index("X_inter", "num_inter", num_inter);
      current_statement__ = 150;
      context__.validate_dims("data initialization","X_inter","double",
          context__.to_vec(num_obs, num_inter));
      X_inter = Eigen::Matrix<double, -1, -1>(num_obs, num_inter);
      stan::math::fill(X_inter, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> X_inter_flat__;
        current_statement__ = 150;
        assign(X_inter_flat__, nil_index_list(), context__.vals_r("X_inter"),
          "assigning variable X_inter_flat__");
        current_statement__ = 150;
        pos__ = 1;
        current_statement__ = 150;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 150;
          for (int sym2__ = 1; sym2__ <= num_obs; ++sym2__) {
            current_statement__ = 150;
            assign(X_inter,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              X_inter_flat__[(pos__ - 1)], "assigning variable X_inter");
            current_statement__ = 150;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 151;
      validate_non_negative_index("group", "num_obs", num_obs);
      current_statement__ = 152;
      context__.validate_dims("data initialization","group","int",
          context__.to_vec(num_obs));
      group = std::vector<int>(num_obs, std::numeric_limits<int>::min());
      
      current_statement__ = 152;
      assign(group, nil_index_list(), context__.vals_i("group"),
        "assigning variable group");
      current_statement__ = 152;
      for (int sym1__ = 1; sym1__ <= num_obs; ++sym1__) {
        current_statement__ = 152;
        current_statement__ = 152;
        check_greater_or_equal(function__, "group[sym1__]",
                               group[(sym1__ - 1)], 1);}
      current_statement__ = 153;
      validate_non_negative_index("stratum", "num_obs", num_obs);
      current_statement__ = 154;
      context__.validate_dims("data initialization","stratum","int",
          context__.to_vec(num_obs));
      stratum = std::vector<int>(num_obs, std::numeric_limits<int>::min());
      
      current_statement__ = 154;
      assign(stratum, nil_index_list(), context__.vals_i("stratum"),
        "assigning variable stratum");
      current_statement__ = 154;
      for (int sym1__ = 1; sym1__ <= num_obs; ++sym1__) {
        current_statement__ = 154;
        current_statement__ = 154;
        check_greater_or_equal(function__, "stratum[sym1__]",
                               stratum[(sym1__ - 1)], 1);}
      current_statement__ = 155;
      context__.validate_dims("data initialization","num_groups","int",
          context__.to_vec());
      num_groups = std::numeric_limits<int>::min();
      
      current_statement__ = 155;
      num_groups = context__.vals_i("num_groups")[(1 - 1)];
      current_statement__ = 155;
      current_statement__ = 155;
      check_greater_or_equal(function__, "num_groups", num_groups, 1);
      current_statement__ = 156;
      context__.validate_dims("data initialization","num_strata","int",
          context__.to_vec());
      num_strata = std::numeric_limits<int>::min();
      
      current_statement__ = 156;
      num_strata = context__.vals_i("num_strata")[(1 - 1)];
      current_statement__ = 156;
      current_statement__ = 156;
      check_greater_or_equal(function__, "num_strata", num_strata, 1);
      current_statement__ = 157;
      validate_non_negative_index("group_stratum_cid", "num_groups",
                                  num_groups);
      current_statement__ = 158;
      context__.validate_dims("data initialization","group_stratum_cid",
          "int",context__.to_vec(num_groups));
      group_stratum_cid = std::vector<int>(num_groups, std::numeric_limits<int>::min());
      
      current_statement__ = 158;
      assign(group_stratum_cid, nil_index_list(),
        context__.vals_i("group_stratum_cid"),
        "assigning variable group_stratum_cid");
      current_statement__ = 158;
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        current_statement__ = 158;
        current_statement__ = 158;
        check_greater_or_equal(function__, "group_stratum_cid[sym1__]",
                               group_stratum_cid[(sym1__ - 1)], 1);}
      current_statement__ = 158;
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        current_statement__ = 158;
        current_statement__ = 158;
        check_less_or_equal(function__, "group_stratum_cid[sym1__]",
                            group_stratum_cid[(sym1__ - 1)], num_strata);}
      current_statement__ = 159;
      validate_non_negative_index("prior_is_EXNEX_comp", "num_comp", num_comp);
      current_statement__ = 160;
      context__.validate_dims("data initialization","prior_is_EXNEX_comp",
          "int",context__.to_vec(num_comp));
      prior_is_EXNEX_comp = std::vector<int>(num_comp, std::numeric_limits<int>::min());
      
      current_statement__ = 160;
      assign(prior_is_EXNEX_comp, nil_index_list(),
        context__.vals_i("prior_is_EXNEX_comp"),
        "assigning variable prior_is_EXNEX_comp");
      current_statement__ = 160;
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        current_statement__ = 160;
        current_statement__ = 160;
        check_greater_or_equal(function__, "prior_is_EXNEX_comp[sym1__]",
                               prior_is_EXNEX_comp[(sym1__ - 1)], 0);}
      current_statement__ = 160;
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        current_statement__ = 160;
        current_statement__ = 160;
        check_less_or_equal(function__, "prior_is_EXNEX_comp[sym1__]",
                            prior_is_EXNEX_comp[(sym1__ - 1)], 1);}
      current_statement__ = 161;
      validate_non_negative_index("prior_is_EXNEX_inter", "num_inter",
                                  num_inter);
      current_statement__ = 162;
      context__.validate_dims("data initialization","prior_is_EXNEX_inter",
          "int",context__.to_vec(num_inter));
      prior_is_EXNEX_inter = std::vector<int>(num_inter, std::numeric_limits<int>::min());
      
      current_statement__ = 162;
      assign(prior_is_EXNEX_inter, nil_index_list(),
        context__.vals_i("prior_is_EXNEX_inter"),
        "assigning variable prior_is_EXNEX_inter");
      current_statement__ = 162;
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        current_statement__ = 162;
        current_statement__ = 162;
        check_greater_or_equal(function__, "prior_is_EXNEX_inter[sym1__]",
                               prior_is_EXNEX_inter[(sym1__ - 1)], 0);}
      current_statement__ = 162;
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        current_statement__ = 162;
        current_statement__ = 162;
        check_less_or_equal(function__, "prior_is_EXNEX_inter[sym1__]",
                            prior_is_EXNEX_inter[(sym1__ - 1)], 1);}
      current_statement__ = 163;
      validate_non_negative_index("prior_EX_prob_comp", "num_groups",
                                  num_groups);
      current_statement__ = 164;
      validate_non_negative_index("prior_EX_prob_comp", "num_comp", num_comp);
      current_statement__ = 165;
      context__.validate_dims("data initialization","prior_EX_prob_comp",
          "double",context__.to_vec(num_groups, num_comp));
      prior_EX_prob_comp = Eigen::Matrix<double, -1, -1>(num_groups, num_comp);
      stan::math::fill(prior_EX_prob_comp, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_EX_prob_comp_flat__;
        current_statement__ = 165;
        assign(prior_EX_prob_comp_flat__, nil_index_list(),
          context__.vals_r("prior_EX_prob_comp"),
          "assigning variable prior_EX_prob_comp_flat__");
        current_statement__ = 165;
        pos__ = 1;
        current_statement__ = 165;
        for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
          current_statement__ = 165;
          for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
            current_statement__ = 165;
            assign(prior_EX_prob_comp,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              prior_EX_prob_comp_flat__[(pos__ - 1)],
              "assigning variable prior_EX_prob_comp");
            current_statement__ = 165;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 165;
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        current_statement__ = 165;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 165;
          current_statement__ = 165;
          check_greater_or_equal(function__,
                                 "prior_EX_prob_comp[sym1__, sym2__]",
                                 rvalue(prior_EX_prob_comp,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())),
                                   "prior_EX_prob_comp"), 1E-6);}}
      current_statement__ = 165;
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        current_statement__ = 165;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 165;
          current_statement__ = 165;
          check_less_or_equal(function__,
                              "prior_EX_prob_comp[sym1__, sym2__]",
                              rvalue(prior_EX_prob_comp,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())), "prior_EX_prob_comp"),
                              1);}}
      current_statement__ = 166;
      validate_non_negative_index("prior_EX_prob_inter", "num_groups",
                                  num_groups);
      current_statement__ = 167;
      validate_non_negative_index("prior_EX_prob_inter", "num_inter",
                                  num_inter);
      current_statement__ = 168;
      context__.validate_dims("data initialization","prior_EX_prob_inter",
          "double",context__.to_vec(num_groups, num_inter));
      prior_EX_prob_inter = Eigen::Matrix<double, -1, -1>(num_groups, num_inter);
      stan::math::fill(prior_EX_prob_inter, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_EX_prob_inter_flat__;
        current_statement__ = 168;
        assign(prior_EX_prob_inter_flat__, nil_index_list(),
          context__.vals_r("prior_EX_prob_inter"),
          "assigning variable prior_EX_prob_inter_flat__");
        current_statement__ = 168;
        pos__ = 1;
        current_statement__ = 168;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 168;
          for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
            current_statement__ = 168;
            assign(prior_EX_prob_inter,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              prior_EX_prob_inter_flat__[(pos__ - 1)],
              "assigning variable prior_EX_prob_inter");
            current_statement__ = 168;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 168;
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        current_statement__ = 168;
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          current_statement__ = 168;
          current_statement__ = 168;
          check_greater_or_equal(function__,
                                 "prior_EX_prob_inter[sym1__, sym2__]",
                                 rvalue(prior_EX_prob_inter,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())),
                                   "prior_EX_prob_inter"), 1E-6);}}
      current_statement__ = 168;
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        current_statement__ = 168;
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          current_statement__ = 168;
          current_statement__ = 168;
          check_less_or_equal(function__,
                              "prior_EX_prob_inter[sym1__, sym2__]",
                              rvalue(prior_EX_prob_inter,
                                cons_list(index_uni(sym1__),
                                  cons_list(index_uni(sym2__),
                                    nil_index_list())),
                                "prior_EX_prob_inter"), 1);}}
      current_statement__ = 169;
      validate_non_negative_index("prior_EX_mu_mean_comp", "num_comp",
                                  num_comp);
      current_statement__ = 170;
      context__.validate_dims("data initialization","prior_EX_mu_mean_comp",
          "double",context__.to_vec(num_comp, 2));
      prior_EX_mu_mean_comp = std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2));
      stan::math::fill(prior_EX_mu_mean_comp, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_EX_mu_mean_comp_flat__;
        current_statement__ = 170;
        assign(prior_EX_mu_mean_comp_flat__, nil_index_list(),
          context__.vals_r("prior_EX_mu_mean_comp"),
          "assigning variable prior_EX_mu_mean_comp_flat__");
        current_statement__ = 170;
        pos__ = 1;
        current_statement__ = 170;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 170;
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            current_statement__ = 170;
            assign(prior_EX_mu_mean_comp,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              prior_EX_mu_mean_comp_flat__[(pos__ - 1)],
              "assigning variable prior_EX_mu_mean_comp");
            current_statement__ = 170;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 171;
      validate_non_negative_index("prior_EX_mu_sd_comp", "num_comp", num_comp);
      current_statement__ = 172;
      context__.validate_dims("data initialization","prior_EX_mu_sd_comp",
          "double",context__.to_vec(num_comp, 2));
      prior_EX_mu_sd_comp = std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2));
      stan::math::fill(prior_EX_mu_sd_comp, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_EX_mu_sd_comp_flat__;
        current_statement__ = 172;
        assign(prior_EX_mu_sd_comp_flat__, nil_index_list(),
          context__.vals_r("prior_EX_mu_sd_comp"),
          "assigning variable prior_EX_mu_sd_comp_flat__");
        current_statement__ = 172;
        pos__ = 1;
        current_statement__ = 172;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 172;
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            current_statement__ = 172;
            assign(prior_EX_mu_sd_comp,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              prior_EX_mu_sd_comp_flat__[(pos__ - 1)],
              "assigning variable prior_EX_mu_sd_comp");
            current_statement__ = 172;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 172;
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        current_statement__ = 172;
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          current_statement__ = 172;
          current_statement__ = 172;
          check_greater_or_equal(function__,
                                 "prior_EX_mu_sd_comp[sym1__, sym2__]",
                                 prior_EX_mu_sd_comp[(sym1__ - 1)][(sym2__ -
                                                                    1)], 0);}
      }
      current_statement__ = 173;
      context__.validate_dims("data initialization","prior_EX_corr_mu_comp",
          "double",context__.to_vec());
      prior_EX_corr_mu_comp = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 173;
      prior_EX_corr_mu_comp = context__.vals_r("prior_EX_corr_mu_comp")[
          (1 - 1)];
      current_statement__ = 173;
      current_statement__ = 173;
      check_greater_or_equal(function__, "prior_EX_corr_mu_comp",
                             prior_EX_corr_mu_comp, -1);
      current_statement__ = 173;
      current_statement__ = 173;
      check_less_or_equal(function__, "prior_EX_corr_mu_comp",
                          prior_EX_corr_mu_comp, 1);
      current_statement__ = 174;
      validate_non_negative_index("prior_EX_tau_mean_comp", "num_strata",
                                  num_strata);
      current_statement__ = 175;
      validate_non_negative_index("prior_EX_tau_mean_comp", "num_comp",
                                  num_comp);
      current_statement__ = 176;
      context__.validate_dims("data initialization","prior_EX_tau_mean_comp",
          "double",context__.to_vec(num_strata, num_comp, 2));
      prior_EX_tau_mean_comp = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(num_strata, std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2)));
      stan::math::fill(prior_EX_tau_mean_comp, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_EX_tau_mean_comp_flat__;
        current_statement__ = 176;
        assign(prior_EX_tau_mean_comp_flat__, nil_index_list(),
          context__.vals_r("prior_EX_tau_mean_comp"),
          "assigning variable prior_EX_tau_mean_comp_flat__");
        current_statement__ = 176;
        pos__ = 1;
        current_statement__ = 176;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 176;
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            current_statement__ = 176;
            for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
              current_statement__ = 176;
              assign(prior_EX_tau_mean_comp,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                prior_EX_tau_mean_comp_flat__[(pos__ - 1)],
                "assigning variable prior_EX_tau_mean_comp");
              current_statement__ = 176;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 177;
      validate_non_negative_index("prior_EX_tau_sd_comp", "num_strata",
                                  num_strata);
      current_statement__ = 178;
      validate_non_negative_index("prior_EX_tau_sd_comp", "num_comp",
                                  num_comp);
      current_statement__ = 179;
      context__.validate_dims("data initialization","prior_EX_tau_sd_comp",
          "double",context__.to_vec(num_strata, num_comp, 2));
      prior_EX_tau_sd_comp = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(num_strata, std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2)));
      stan::math::fill(prior_EX_tau_sd_comp, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_EX_tau_sd_comp_flat__;
        current_statement__ = 179;
        assign(prior_EX_tau_sd_comp_flat__, nil_index_list(),
          context__.vals_r("prior_EX_tau_sd_comp"),
          "assigning variable prior_EX_tau_sd_comp_flat__");
        current_statement__ = 179;
        pos__ = 1;
        current_statement__ = 179;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 179;
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            current_statement__ = 179;
            for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
              current_statement__ = 179;
              assign(prior_EX_tau_sd_comp,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                prior_EX_tau_sd_comp_flat__[(pos__ - 1)],
                "assigning variable prior_EX_tau_sd_comp");
              current_statement__ = 179;
              pos__ = (pos__ + 1);}}}
      }
      current_statement__ = 179;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 179;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 179;
          for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
            current_statement__ = 179;
            current_statement__ = 179;
            check_greater_or_equal(function__,
                                   "prior_EX_tau_sd_comp[sym1__, sym2__, sym3__]",
                                   prior_EX_tau_sd_comp[(sym1__ - 1)][
                                   (sym2__ - 1)][(sym3__ - 1)], 0);}}}
      current_statement__ = 180;
      validate_non_negative_index("prior_EX_corr_eta_comp", "num_comp",
                                  num_comp);
      current_statement__ = 181;
      context__.validate_dims("data initialization","prior_EX_corr_eta_comp",
          "double",context__.to_vec(num_comp));
      prior_EX_corr_eta_comp = std::vector<double>(num_comp, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 181;
      assign(prior_EX_corr_eta_comp, nil_index_list(),
        context__.vals_r("prior_EX_corr_eta_comp"),
        "assigning variable prior_EX_corr_eta_comp");
      current_statement__ = 181;
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        current_statement__ = 181;
        current_statement__ = 181;
        check_greater_or_equal(function__, "prior_EX_corr_eta_comp[sym1__]",
                               prior_EX_corr_eta_comp[(sym1__ - 1)], 0);}
      current_statement__ = 182;
      validate_non_negative_index("prior_EX_mu_mean_inter", "num_inter",
                                  num_inter);
      current_statement__ = 183;
      context__.validate_dims("data initialization","prior_EX_mu_mean_inter",
          "double",context__.to_vec(num_inter));
      prior_EX_mu_mean_inter = Eigen::Matrix<double, -1, 1>(num_inter);
      stan::math::fill(prior_EX_mu_mean_inter, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_EX_mu_mean_inter_flat__;
        current_statement__ = 183;
        assign(prior_EX_mu_mean_inter_flat__, nil_index_list(),
          context__.vals_r("prior_EX_mu_mean_inter"),
          "assigning variable prior_EX_mu_mean_inter_flat__");
        current_statement__ = 183;
        pos__ = 1;
        current_statement__ = 183;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 183;
          assign(prior_EX_mu_mean_inter,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_EX_mu_mean_inter_flat__[(pos__ - 1)],
            "assigning variable prior_EX_mu_mean_inter");
          current_statement__ = 183;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 184;
      validate_non_negative_index("prior_EX_mu_sd_inter", "num_inter",
                                  num_inter);
      current_statement__ = 185;
      context__.validate_dims("data initialization","prior_EX_mu_sd_inter",
          "double",context__.to_vec(num_inter));
      prior_EX_mu_sd_inter = Eigen::Matrix<double, -1, 1>(num_inter);
      stan::math::fill(prior_EX_mu_sd_inter, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_EX_mu_sd_inter_flat__;
        current_statement__ = 185;
        assign(prior_EX_mu_sd_inter_flat__, nil_index_list(),
          context__.vals_r("prior_EX_mu_sd_inter"),
          "assigning variable prior_EX_mu_sd_inter_flat__");
        current_statement__ = 185;
        pos__ = 1;
        current_statement__ = 185;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 185;
          assign(prior_EX_mu_sd_inter,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_EX_mu_sd_inter_flat__[(pos__ - 1)],
            "assigning variable prior_EX_mu_sd_inter");
          current_statement__ = 185;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 185;
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        current_statement__ = 185;
        current_statement__ = 185;
        check_greater_or_equal(function__, "prior_EX_mu_sd_inter[sym1__]",
                               prior_EX_mu_sd_inter[(sym1__ - 1)], 0);}
      current_statement__ = 186;
      validate_non_negative_index("prior_EX_tau_mean_inter", "num_strata",
                                  num_strata);
      current_statement__ = 187;
      validate_non_negative_index("prior_EX_tau_mean_inter", "num_inter",
                                  num_inter);
      current_statement__ = 188;
      context__.validate_dims("data initialization",
          "prior_EX_tau_mean_inter","double",
          context__.to_vec(num_strata, num_inter));
      prior_EX_tau_mean_inter = std::vector<Eigen::Matrix<double, -1, 1>>(num_strata, Eigen::Matrix<double, -1, 1>(num_inter));
      stan::math::fill(prior_EX_tau_mean_inter, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_EX_tau_mean_inter_flat__;
        current_statement__ = 188;
        assign(prior_EX_tau_mean_inter_flat__, nil_index_list(),
          context__.vals_r("prior_EX_tau_mean_inter"),
          "assigning variable prior_EX_tau_mean_inter_flat__");
        current_statement__ = 188;
        pos__ = 1;
        current_statement__ = 188;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 188;
          for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
            current_statement__ = 188;
            assign(prior_EX_tau_mean_inter,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              prior_EX_tau_mean_inter_flat__[(pos__ - 1)],
              "assigning variable prior_EX_tau_mean_inter");
            current_statement__ = 188;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 189;
      validate_non_negative_index("prior_EX_tau_sd_inter", "num_strata",
                                  num_strata);
      current_statement__ = 190;
      validate_non_negative_index("prior_EX_tau_sd_inter", "num_inter",
                                  num_inter);
      current_statement__ = 191;
      context__.validate_dims("data initialization","prior_EX_tau_sd_inter",
          "double",context__.to_vec(num_strata, num_inter));
      prior_EX_tau_sd_inter = std::vector<Eigen::Matrix<double, -1, 1>>(num_strata, Eigen::Matrix<double, -1, 1>(num_inter));
      stan::math::fill(prior_EX_tau_sd_inter, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_EX_tau_sd_inter_flat__;
        current_statement__ = 191;
        assign(prior_EX_tau_sd_inter_flat__, nil_index_list(),
          context__.vals_r("prior_EX_tau_sd_inter"),
          "assigning variable prior_EX_tau_sd_inter_flat__");
        current_statement__ = 191;
        pos__ = 1;
        current_statement__ = 191;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 191;
          for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
            current_statement__ = 191;
            assign(prior_EX_tau_sd_inter,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              prior_EX_tau_sd_inter_flat__[(pos__ - 1)],
              "assigning variable prior_EX_tau_sd_inter");
            current_statement__ = 191;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 191;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 191;
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          current_statement__ = 191;
          current_statement__ = 191;
          check_greater_or_equal(function__,
                                 "prior_EX_tau_sd_inter[sym1__, sym2__]",
                                 prior_EX_tau_sd_inter[(sym1__ - 1)][
                                 (sym2__ - 1)], 0);}}
      current_statement__ = 192;
      context__.validate_dims("data initialization",
          "prior_EX_corr_eta_inter","double",context__.to_vec());
      prior_EX_corr_eta_inter = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 192;
      prior_EX_corr_eta_inter = context__.vals_r("prior_EX_corr_eta_inter")[
          (1 - 1)];
      current_statement__ = 192;
      current_statement__ = 192;
      check_greater_or_equal(function__, "prior_EX_corr_eta_inter",
                             prior_EX_corr_eta_inter, 0);
      current_statement__ = 193;
      validate_non_negative_index("prior_NEX_mu_mean_comp", "num_comp",
                                  num_comp);
      current_statement__ = 194;
      context__.validate_dims("data initialization","prior_NEX_mu_mean_comp",
          "double",context__.to_vec(num_comp, 2));
      prior_NEX_mu_mean_comp = std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2));
      stan::math::fill(prior_NEX_mu_mean_comp, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_NEX_mu_mean_comp_flat__;
        current_statement__ = 194;
        assign(prior_NEX_mu_mean_comp_flat__, nil_index_list(),
          context__.vals_r("prior_NEX_mu_mean_comp"),
          "assigning variable prior_NEX_mu_mean_comp_flat__");
        current_statement__ = 194;
        pos__ = 1;
        current_statement__ = 194;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 194;
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            current_statement__ = 194;
            assign(prior_NEX_mu_mean_comp,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              prior_NEX_mu_mean_comp_flat__[(pos__ - 1)],
              "assigning variable prior_NEX_mu_mean_comp");
            current_statement__ = 194;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 195;
      validate_non_negative_index("prior_NEX_mu_sd_comp", "num_comp",
                                  num_comp);
      current_statement__ = 196;
      context__.validate_dims("data initialization","prior_NEX_mu_sd_comp",
          "double",context__.to_vec(num_comp, 2));
      prior_NEX_mu_sd_comp = std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2));
      stan::math::fill(prior_NEX_mu_sd_comp, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_NEX_mu_sd_comp_flat__;
        current_statement__ = 196;
        assign(prior_NEX_mu_sd_comp_flat__, nil_index_list(),
          context__.vals_r("prior_NEX_mu_sd_comp"),
          "assigning variable prior_NEX_mu_sd_comp_flat__");
        current_statement__ = 196;
        pos__ = 1;
        current_statement__ = 196;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 196;
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            current_statement__ = 196;
            assign(prior_NEX_mu_sd_comp,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              prior_NEX_mu_sd_comp_flat__[(pos__ - 1)],
              "assigning variable prior_NEX_mu_sd_comp");
            current_statement__ = 196;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 196;
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        current_statement__ = 196;
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          current_statement__ = 196;
          current_statement__ = 196;
          check_greater_or_equal(function__,
                                 "prior_NEX_mu_sd_comp[sym1__, sym2__]",
                                 prior_NEX_mu_sd_comp[(sym1__ - 1)][(sym2__ -
                                                                    1)], 0);}
      }
      current_statement__ = 197;
      validate_non_negative_index("prior_NEX_mu_mean_inter", "num_inter",
                                  num_inter);
      current_statement__ = 198;
      context__.validate_dims("data initialization",
          "prior_NEX_mu_mean_inter","double",context__.to_vec(num_inter));
      prior_NEX_mu_mean_inter = Eigen::Matrix<double, -1, 1>(num_inter);
      stan::math::fill(prior_NEX_mu_mean_inter, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_NEX_mu_mean_inter_flat__;
        current_statement__ = 198;
        assign(prior_NEX_mu_mean_inter_flat__, nil_index_list(),
          context__.vals_r("prior_NEX_mu_mean_inter"),
          "assigning variable prior_NEX_mu_mean_inter_flat__");
        current_statement__ = 198;
        pos__ = 1;
        current_statement__ = 198;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 198;
          assign(prior_NEX_mu_mean_inter,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_NEX_mu_mean_inter_flat__[(pos__ - 1)],
            "assigning variable prior_NEX_mu_mean_inter");
          current_statement__ = 198;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 199;
      validate_non_negative_index("prior_NEX_mu_sd_inter", "num_inter",
                                  num_inter);
      current_statement__ = 200;
      context__.validate_dims("data initialization","prior_NEX_mu_sd_inter",
          "double",context__.to_vec(num_inter));
      prior_NEX_mu_sd_inter = Eigen::Matrix<double, -1, 1>(num_inter);
      stan::math::fill(prior_NEX_mu_sd_inter, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_NEX_mu_sd_inter_flat__;
        current_statement__ = 200;
        assign(prior_NEX_mu_sd_inter_flat__, nil_index_list(),
          context__.vals_r("prior_NEX_mu_sd_inter"),
          "assigning variable prior_NEX_mu_sd_inter_flat__");
        current_statement__ = 200;
        pos__ = 1;
        current_statement__ = 200;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 200;
          assign(prior_NEX_mu_sd_inter,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_NEX_mu_sd_inter_flat__[(pos__ - 1)],
            "assigning variable prior_NEX_mu_sd_inter");
          current_statement__ = 200;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 200;
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        current_statement__ = 200;
        current_statement__ = 200;
        check_greater_or_equal(function__, "prior_NEX_mu_sd_inter[sym1__]",
                               prior_NEX_mu_sd_inter[(sym1__ - 1)], 0);}
      current_statement__ = 201;
      context__.validate_dims("data initialization","prior_tau_dist","int",
          context__.to_vec());
      prior_tau_dist = std::numeric_limits<int>::min();
      
      current_statement__ = 201;
      prior_tau_dist = context__.vals_i("prior_tau_dist")[(1 - 1)];
      current_statement__ = 201;
      current_statement__ = 201;
      check_greater_or_equal(function__, "prior_tau_dist", prior_tau_dist, 0);
      current_statement__ = 201;
      current_statement__ = 201;
      check_less_or_equal(function__, "prior_tau_dist", prior_tau_dist, 2);
      current_statement__ = 202;
      context__.validate_dims("data initialization","prior_PD","int",
          context__.to_vec());
      prior_PD = std::numeric_limits<int>::min();
      
      current_statement__ = 202;
      prior_PD = context__.vals_i("prior_PD")[(1 - 1)];
      current_statement__ = 202;
      current_statement__ = 202;
      check_greater_or_equal(function__, "prior_PD", prior_PD, 0);
      current_statement__ = 202;
      current_statement__ = 202;
      check_less_or_equal(function__, "prior_PD", prior_PD, 1);
      current_statement__ = 203;
      validate_non_negative_index("n", "num_obs", num_obs);
      current_statement__ = 204;
      n = std::vector<int>(num_obs, std::numeric_limits<int>::min());
      
      current_statement__ = 205;
      validate_non_negative_index("finite_cov", "num_comp", num_comp);
      current_statement__ = 206;
      validate_non_negative_index("finite_cov", "num_obs", num_obs);
      current_statement__ = 207;
      finite_cov = std::vector<std::vector<int>>(num_comp, std::vector<int>(num_obs, std::numeric_limits<int>::min()));
      
      current_statement__ = 208;
      num_EXNEX_comp = std::numeric_limits<int>::min();
      
      current_statement__ = 208;
      num_EXNEX_comp = sum(prior_is_EXNEX_comp);
      current_statement__ = 209;
      num_EXNEX_inter = std::numeric_limits<int>::min();
      
      current_statement__ = 209;
      num_EXNEX_inter = sum(prior_is_EXNEX_inter);
      current_statement__ = 210;
      num_mix_dim = std::numeric_limits<int>::min();
      
      current_statement__ = 210;
      num_mix_dim = (num_EXNEX_comp + num_EXNEX_inter);
      current_statement__ = 211;
      num_mix_comp = std::numeric_limits<int>::min();
      
      current_statement__ = 211;
      num_mix_comp = power_int(2, num_mix_dim, pstream__);
      current_statement__ = 212;
      validate_non_negative_index("mix_is_EX_beta", "num_EXNEX_comp",
                                  num_EXNEX_comp);
      current_statement__ = 213;
      validate_non_negative_index("mix_is_EX_beta",
                                  "num_mix_dim == 0 ? 0 : power_int(2, num_mix_dim - 1)",
                                  (logical_eq(num_mix_dim, 0) ? 0 :
                                     power_int(2,
                                       (num_mix_dim - 1), pstream__)));
      current_statement__ = 214;
      mix_is_EX_beta = std::vector<std::vector<int>>(num_EXNEX_comp, std::vector<int>((
        logical_eq(num_mix_dim, 0) ? 0 :
          power_int(2, (num_mix_dim - 1), pstream__)), std::numeric_limits<int>::min()));
      
      current_statement__ = 215;
      validate_non_negative_index("mix_is_EX_eta", "num_EXNEX_inter",
                                  num_EXNEX_inter);
      current_statement__ = 216;
      validate_non_negative_index("mix_is_EX_eta",
                                  "num_mix_dim == 0 ? 0 : power_int(2, num_mix_dim - 1)",
                                  (logical_eq(num_mix_dim, 0) ? 0 :
                                     power_int(2,
                                       (num_mix_dim - 1), pstream__)));
      current_statement__ = 217;
      mix_is_EX_eta = std::vector<std::vector<int>>(num_EXNEX_inter, std::vector<int>((
        logical_eq(num_mix_dim, 0) ? 0 :
          power_int(2, (num_mix_dim - 1), pstream__)), std::numeric_limits<int>::min()));
      
      current_statement__ = 218;
      validate_non_negative_index("mix_idx_beta", "num_mix_comp",
                                  num_mix_comp);
      current_statement__ = 219;
      validate_non_negative_index("mix_idx_beta", "num_comp", num_comp);
      current_statement__ = 220;
      mix_idx_beta = std::vector<std::vector<int>>(num_mix_comp, std::vector<int>(num_comp, std::numeric_limits<int>::min()));
      
      current_statement__ = 221;
      validate_non_negative_index("mix_idx_eta", "num_mix_comp", num_mix_comp);
      current_statement__ = 222;
      validate_non_negative_index("mix_idx_eta", "num_inter", num_inter);
      current_statement__ = 223;
      mix_idx_eta = std::vector<std::vector<int>>(num_mix_comp, std::vector<int>(num_inter, std::numeric_limits<int>::min()));
      
      current_statement__ = 224;
      validate_non_negative_index("num_obs_group", "num_groups", num_groups);
      current_statement__ = 225;
      num_obs_group = std::vector<int>(num_groups, std::numeric_limits<int>::min());
      
      current_statement__ = 225;
      assign(num_obs_group, nil_index_list(),
        count_elems(group, seq_int(1, num_groups, pstream__), pstream__),
        "assigning variable num_obs_group");
      current_statement__ = 226;
      validate_non_negative_index("num_cases_group", "num_groups", num_groups);
      current_statement__ = 227;
      num_cases_group = std::vector<int>(num_groups, std::numeric_limits<int>::min());
      
      current_statement__ = 227;
      assign(num_cases_group, nil_index_list(), rep_array(0, num_groups),
        "assigning variable num_cases_group");
      current_statement__ = 228;
      validate_non_negative_index("group_obs_idx", "num_groups", num_groups);
      current_statement__ = 229;
      validate_non_negative_index("group_obs_idx", "max(num_obs_group)",
                                  max(num_obs_group));
      current_statement__ = 230;
      group_obs_idx = std::vector<std::vector<int>>(num_groups, std::vector<int>(
        max(num_obs_group), std::numeric_limits<int>::min()));
      
      current_statement__ = 230;
      assign(group_obs_idx, nil_index_list(),
        rep_array(0, num_groups, max(num_obs_group)),
        "assigning variable group_obs_idx");
      current_statement__ = 231;
      validate_non_negative_index("mix_log_weight", "num_groups", num_groups);
      current_statement__ = 232;
      validate_non_negative_index("mix_log_weight", "num_mix_comp",
                                  num_mix_comp);
      current_statement__ = 233;
      mix_log_weight = std::vector<Eigen::Matrix<double, -1, 1>>(num_groups, Eigen::Matrix<double, -1, 1>(num_mix_comp));
      stan::math::fill(mix_log_weight, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 234;
      validate_non_negative_index("log_normfactor_group", "num_groups",
                                  num_groups);
      current_statement__ = 235;
      log_normfactor_group = Eigen::Matrix<double, -1, 1>(num_groups);
      stan::math::fill(log_normfactor_group, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 235;
      assign(log_normfactor_group, nil_index_list(),
        rep_vector(0, num_groups), "assigning variable log_normfactor_group");
      current_statement__ = 244;
      for (int g = 1; g <= num_groups; ++g) {
        int i;
        i = std::numeric_limits<int>::min();
        
        current_statement__ = 236;
        i = 1;
        current_statement__ = 242;
        for (int o = 1; o <= num_obs; ++o) {
          current_statement__ = 240;
          if (logical_eq(group[(o - 1)], g)) {
            current_statement__ = 237;
            assign(group_obs_idx,
              cons_list(index_uni(g),
                cons_list(index_uni(i), nil_index_list())), o,
              "assigning variable group_obs_idx");
            current_statement__ = 238;
            i = (i + 1);
          } }}
      current_statement__ = 251;
      for (int g = 1; g <= num_groups; ++g) {
        int group_size;
        group_size = std::numeric_limits<int>::min();
        
        current_statement__ = 245;
        group_size = num_obs_group[(g - 1)];
        current_statement__ = 246;
        validate_non_negative_index("obs_gidx", "group_size", group_size);
        std::vector<int> obs_gidx;
        obs_gidx = std::vector<int>(group_size, std::numeric_limits<int>::min());
        
        current_statement__ = 247;
        assign(obs_gidx, nil_index_list(),
          rvalue(group_obs_idx,
            cons_list(index_uni(g),
              cons_list(index_min_max(1, group_size), nil_index_list())),
            "group_obs_idx"), "assigning variable obs_gidx");
        current_statement__ = 249;
        if (logical_gt(
              cardinality_int(
                rvalue(stratum,
                  cons_list(index_multi(obs_gidx), nil_index_list()),
                  "stratum"), pstream__), 1)) {
          current_statement__ = 248;
          std::stringstream errmsg_stream__;
          errmsg_stream__ << "Group ";
          errmsg_stream__ << g;
          errmsg_stream__ << " is assigned to multiple strata.";
          throw std::domain_error(errmsg_stream__.str());
        } }
      current_statement__ = 257;
      for (int j = 1; j <= num_comp; ++j) {
        current_statement__ = 252;
        validate_non_negative_index("X_comp_intercept", "num_obs", num_obs);
        Eigen::Matrix<double, -1, 1> X_comp_intercept;
        X_comp_intercept = Eigen::Matrix<double, -1, 1>(num_obs);
        stan::math::fill(X_comp_intercept, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 253;
        assign(X_comp_intercept, nil_index_list(),
          rvalue(X_comp,
            cons_list(index_uni(j),
              cons_list(index_omni(),
                cons_list(index_uni(1), nil_index_list()))), "X_comp"),
          "assigning variable X_comp_intercept");
        current_statement__ = 255;
        if ((primitive_value(
            logical_gt(cardinality_vector(X_comp_intercept, pstream__), 1))
            || primitive_value(
            logical_neq(
              rvalue(X_comp,
                cons_list(index_uni(j),
                  cons_list(index_uni(1),
                    cons_list(index_uni(1), nil_index_list()))), "X_comp"),
              1.0)))) {
          current_statement__ = 254;
          std::stringstream errmsg_stream__;
          errmsg_stream__ << "Compound (";
          errmsg_stream__ << j;
          errmsg_stream__ << ") design matrix must have an intercept.";
          throw std::domain_error(errmsg_stream__.str());
        } }
      current_statement__ = 263;
      if (logical_gt(num_inter, 0)) {
        current_statement__ = 258;
        validate_non_negative_index("X_inter_intercept", "num_obs", num_obs);
        Eigen::Matrix<double, -1, 1> X_inter_intercept;
        X_inter_intercept = Eigen::Matrix<double, -1, 1>(num_obs);
        stan::math::fill(X_inter_intercept, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 259;
        assign(X_inter_intercept, nil_index_list(),
          rvalue(X_inter,
            cons_list(index_omni(),
              cons_list(index_uni(1), nil_index_list())), "X_inter"),
          "assigning variable X_inter_intercept");
        current_statement__ = 261;
        if ((primitive_value(
            logical_eq(cardinality_vector(X_inter_intercept, pstream__), 1))
            && primitive_value(
            logical_eq(
              rvalue(X_inter,
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list())), "X_inter"),
              1.0)))) {
          current_statement__ = 260;
          if (pstream__) {
            stan_print(pstream__, "INFO: Interaction design matrix appears to have an intercept, which is unexpected.");
            stan_print(pstream__, "\n");
          }
        } 
      } 
      current_statement__ = 267;
      for (int i = 1; i <= num_obs; ++i) {
        current_statement__ = 264;
        assign(n, cons_list(index_uni(i), nil_index_list()),
          (r[(i - 1)] + nr[(i - 1)]), "assigning variable n");
        current_statement__ = 265;
        assign(log_normfactor_group,
          cons_list(index_uni(group[(i - 1)]), nil_index_list()),
          (log_normfactor_group[(group[(i - 1)] - 1)] +
            binomial_coefficient_log(n[(i - 1)], r[(i - 1)])),
          "assigning variable log_normfactor_group");}
      current_statement__ = 273;
      for (int g = 1; g <= num_groups; ++g) {
        int group_size;
        group_size = std::numeric_limits<int>::min();
        
        current_statement__ = 268;
        group_size = num_obs_group[(g - 1)];
        current_statement__ = 269;
        validate_non_negative_index("obs_gidx", "group_size", group_size);
        std::vector<int> obs_gidx;
        obs_gidx = std::vector<int>(group_size, std::numeric_limits<int>::min());
        
        current_statement__ = 270;
        assign(obs_gidx, nil_index_list(),
          rvalue(group_obs_idx,
            cons_list(index_uni(g),
              cons_list(index_min_max(1, group_size), nil_index_list())),
            "group_obs_idx"), "assigning variable obs_gidx");
        current_statement__ = 271;
        assign(num_cases_group, cons_list(index_uni(g), nil_index_list()),
          sum(
            rvalue(n, cons_list(index_multi(obs_gidx), nil_index_list()),
              "n")), "assigning variable num_cases_group");}
      {
        current_statement__ = 274;
        validate_non_negative_index("finite_cov_sum", "num_obs", num_obs);
        std::vector<int> finite_cov_sum;
        finite_cov_sum = std::vector<int>(num_obs, std::numeric_limits<int>::min());
        
        current_statement__ = 275;
        assign(finite_cov_sum, nil_index_list(), rep_array(0, num_obs),
          "assigning variable finite_cov_sum");
        current_statement__ = 281;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 279;
          for (int i = 1; i <= num_obs; ++i) {
            current_statement__ = 276;
            assign(finite_cov,
              cons_list(index_uni(j),
                cons_list(index_uni(i), nil_index_list())),
              ((primitive_value(
                 logical_negation(
                   is_inf(
                     rvalue(X_comp,
                       cons_list(index_uni(j),
                         cons_list(index_uni(i),
                           cons_list(index_uni(1), nil_index_list()))),
                       "X_comp")))) && primitive_value(
                 logical_negation(
                   is_inf(
                     rvalue(X_comp,
                       cons_list(index_uni(j),
                         cons_list(index_uni(i),
                           cons_list(index_uni(2), nil_index_list()))),
                       "X_comp"))))) ? 1 : 0),
              "assigning variable finite_cov");
            current_statement__ = 277;
            assign(finite_cov_sum, cons_list(index_uni(i), nil_index_list()),
              (finite_cov_sum[(i - 1)] + finite_cov[(j - 1)][(i - 1)]),
              "assigning variable finite_cov_sum");}}
        current_statement__ = 285;
        for (int i = 1; i <= num_obs; ++i) {
          current_statement__ = 283;
          if (logical_eq(finite_cov_sum[(i - 1)], 0)) {
            current_statement__ = 282;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "No finite covariates for observation ";
            errmsg_stream__ << i;
            throw std::domain_error(errmsg_stream__.str());
          } }
      }
      current_statement__ = 287;
      if (pstream__) {
        stan_print(pstream__, "Number of groups: ");
        stan_print(pstream__, num_groups);
        stan_print(pstream__, "\n");
      }
      current_statement__ = 288;
      if (pstream__) {
        stan_print(pstream__, "Number of strata: ");
        stan_print(pstream__, num_strata);
        stan_print(pstream__, "\n");
      }
      current_statement__ = 289;
      if (pstream__) {
        stan_print(pstream__, "EXNEX enabled for compounds ");
        stan_print(pstream__, num_EXNEX_comp);
        stan_print(pstream__, "/");
        stan_print(pstream__, num_comp);
        stan_print(pstream__, ":    ");
        stan_print(pstream__, prior_is_EXNEX_comp);
        stan_print(pstream__, "\n");
      }
      current_statement__ = 290;
      if (pstream__) {
        stan_print(pstream__, "EXNEX enabled for interactions ");
        stan_print(pstream__, num_EXNEX_inter);
        stan_print(pstream__, "/");
        stan_print(pstream__, num_inter);
        stan_print(pstream__, ": ");
        stan_print(pstream__, prior_is_EXNEX_inter);
        stan_print(pstream__, "\n");
      }
      current_statement__ = 291;
      if (pstream__) {
        stan_print(pstream__, "EXNEX mixture dimensionality ");
        stan_print(pstream__, num_mix_dim);
        stan_print(pstream__, " leads to ");
        stan_print(pstream__, num_mix_comp);
        stan_print(pstream__, " combinations.");
        stan_print(pstream__, "\n");
      }
      current_statement__ = 292;
      if (pstream__) {
        stan_print(pstream__, "Observation => group assignment:");
        stan_print(pstream__, "\n");
      }
      current_statement__ = 295;
      for (int g = 1; g <= num_groups; ++g) {
        current_statement__ = 293;
        if (pstream__) {
          stan_print(pstream__, "Group ");
          stan_print(pstream__, g);
          stan_print(pstream__, ": ");
          stan_print(pstream__, rvalue(group_obs_idx,
                                  cons_list(index_uni(g),
                                    cons_list(
                                      index_min_max(1, num_obs_group[
                                      (g - 1)]), nil_index_list())),
                                  "group_obs_idx"));
          stan_print(pstream__, "\n");
        }}
      current_statement__ = 296;
      if (pstream__) {
        stan_print(pstream__, "");
        stan_print(pstream__, "\n");
      }
      current_statement__ = 297;
      if (pstream__) {
        stan_print(pstream__, "Group => stratum assignment:");
        stan_print(pstream__, "\n");
      }
      current_statement__ = 300;
      for (int g = 1; g <= num_groups; ++g) {
        current_statement__ = 298;
        if (pstream__) {
          stan_print(pstream__, g);
          stan_print(pstream__, " => ");
          stan_print(pstream__, group_stratum_cid[(g - 1)]);
          stan_print(pstream__, "\n");
        }}
      current_statement__ = 301;
      if (pstream__) {
        stan_print(pstream__, "Prior distribution on tau parameters:");
        stan_print(pstream__, "\n");
      }
      current_statement__ = 310;
      if (logical_eq(prior_tau_dist, 0)) {
        current_statement__ = 308;
        if (pstream__) {
          stan_print(pstream__, "Fixed");
          stan_print(pstream__, "\n");
        }
      } else {
        current_statement__ = 307;
        if (logical_eq(prior_tau_dist, 1)) {
          current_statement__ = 305;
          if (pstream__) {
            stan_print(pstream__, "Log-Normal");
            stan_print(pstream__, "\n");
          }
        } else {
          current_statement__ = 304;
          if (logical_eq(prior_tau_dist, 2)) {
            current_statement__ = 302;
            if (pstream__) {
              stan_print(pstream__, "Truncated Normal");
              stan_print(pstream__, "\n");
            }
          } 
        }
      }
      current_statement__ = 312;
      if (prior_PD) {
        current_statement__ = 311;
        if (pstream__) {
          stan_print(pstream__, "Info: Sampling from prior predictive distribution.");
          stan_print(pstream__, "\n");
        }
      } 
      current_statement__ = 314;
      for (int g = 1; g <= num_groups; ++g) {
        current_statement__ = 313;
        assign(mix_log_weight, cons_list(index_uni(g), nil_index_list()),
          rep_vector(0.0, num_mix_comp), "assigning variable mix_log_weight");
      }
      current_statement__ = 353;
      for (int i = 1; i <= num_mix_comp; ++i) {
        current_statement__ = 315;
        validate_non_negative_index("mix_ind_base", "num_mix_dim",
                                    num_mix_dim);
        std::vector<int> mix_ind_base;
        mix_ind_base = std::vector<int>(num_mix_dim, std::numeric_limits<int>::min());
        
        current_statement__ = 316;
        assign(mix_ind_base, nil_index_list(),
          decimal2base((i - 1), num_mix_dim, 2, pstream__),
          "assigning variable mix_ind_base");
        current_statement__ = 317;
        validate_non_negative_index("mix_ind", "num_comp + num_inter",
                                    (num_comp + num_inter));
        std::vector<int> mix_ind;
        mix_ind = std::vector<int>((num_comp + num_inter), std::numeric_limits<int>::min());
        
        current_statement__ = 321;
        for (int j = 1; j <= num_mix_dim; ++j) {
          current_statement__ = 319;
          assign(mix_ind_base, cons_list(index_uni(j), nil_index_list()),
            (mix_ind_base[(j - 1)] + 1), "assigning variable mix_ind_base");}
        {
          int k;
          k = std::numeric_limits<int>::min();
          
          current_statement__ = 322;
          k = 1;
          current_statement__ = 330;
          for (int j = 1; j <= num_comp; ++j) {
            current_statement__ = 328;
            if (prior_is_EXNEX_comp[(j - 1)]) {
              current_statement__ = 325;
              assign(mix_ind, cons_list(index_uni(j), nil_index_list()),
                mix_ind_base[(k - 1)], "assigning variable mix_ind");
              current_statement__ = 326;
              k = (k + 1);
            } else {
              current_statement__ = 323;
              assign(mix_ind, cons_list(index_uni(j), nil_index_list()), 1,
                "assigning variable mix_ind");
            }}
        }
        {
          int k;
          k = std::numeric_limits<int>::min();
          
          current_statement__ = 332;
          k = 1;
          current_statement__ = 340;
          for (int j = 1; j <= num_inter; ++j) {
            current_statement__ = 338;
            if (prior_is_EXNEX_inter[(j - 1)]) {
              current_statement__ = 335;
              assign(mix_ind,
                cons_list(index_uni((num_comp + j)), nil_index_list()),
                mix_ind_base[((num_EXNEX_comp + k) - 1)],
                "assigning variable mix_ind");
              current_statement__ = 336;
              k = (k + 1);
            } else {
              current_statement__ = 333;
              assign(mix_ind,
                cons_list(index_uni((num_comp + j)), nil_index_list()), 1,
                "assigning variable mix_ind");
            }}
        }
        current_statement__ = 351;
        for (int g = 1; g <= num_groups; ++g) {
          current_statement__ = 344;
          for (int j = 1; j <= num_comp; ++j) {
            current_statement__ = 343;
            if (prior_is_EXNEX_comp[(j - 1)]) {
              current_statement__ = 342;
              assign(mix_log_weight,
                cons_list(index_uni(g),
                  cons_list(index_uni(i), nil_index_list())),
                (mix_log_weight[(g - 1)][(i - 1)] +
                  (logical_eq(mix_ind[(j - 1)], 1) ?
                     stan::math::log(
                       rvalue(prior_EX_prob_comp,
                         cons_list(index_uni(g),
                           cons_list(index_uni(j), nil_index_list())),
                         "prior_EX_prob_comp")) :
                     log1m(
                       rvalue(prior_EX_prob_comp,
                         cons_list(index_uni(g),
                           cons_list(index_uni(j), nil_index_list())),
                         "prior_EX_prob_comp")))),
                "assigning variable mix_log_weight");
            } }
          current_statement__ = 347;
          for (int j = 1; j <= num_inter; ++j) {
            current_statement__ = 346;
            if (prior_is_EXNEX_inter[(j - 1)]) {
              current_statement__ = 345;
              assign(mix_log_weight,
                cons_list(index_uni(g),
                  cons_list(index_uni(i), nil_index_list())),
                (mix_log_weight[(g - 1)][(i - 1)] +
                  (logical_eq(mix_ind[((num_comp + j) - 1)], 1) ?
                     stan::math::log(
                       rvalue(prior_EX_prob_inter,
                         cons_list(index_uni(g),
                           cons_list(index_uni(j), nil_index_list())),
                         "prior_EX_prob_inter")) :
                     log1m(
                       rvalue(prior_EX_prob_inter,
                         cons_list(index_uni(g),
                           cons_list(index_uni(j), nil_index_list())),
                         "prior_EX_prob_inter")))),
                "assigning variable mix_log_weight");
            } }
          current_statement__ = 348;
          assign(mix_idx_beta, cons_list(index_uni(i), nil_index_list()),
            rvalue(mix_ind,
              cons_list(index_min_max(1, num_comp), nil_index_list()),
              "mix_ind"), "assigning variable mix_idx_beta");
          current_statement__ = 349;
          assign(mix_idx_eta, cons_list(index_uni(i), nil_index_list()),
            rvalue(mix_ind,
              cons_list(
                index_min_max((num_comp + 1), (num_comp + num_inter)),
                nil_index_list()), "mix_ind"),
            "assigning variable mix_idx_eta");}}
      {
        int i;
        i = std::numeric_limits<int>::min();
        
        current_statement__ = 354;
        i = 1;
        current_statement__ = 360;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 358;
          if (prior_is_EXNEX_comp[(j - 1)]) {
            current_statement__ = 355;
            assign(mix_is_EX_beta, cons_list(index_uni(i), nil_index_list()),
              which_elem(
                rvalue(mix_idx_beta,
                  cons_list(index_omni(),
                    cons_list(index_uni(j), nil_index_list())),
                  "mix_idx_beta"), 1, pstream__),
              "assigning variable mix_is_EX_beta");
            current_statement__ = 356;
            i = (i + 1);
          } }
      }
      {
        int i;
        i = std::numeric_limits<int>::min();
        
        current_statement__ = 362;
        i = 1;
        current_statement__ = 368;
        for (int j = 1; j <= num_inter; ++j) {
          current_statement__ = 366;
          if (prior_is_EXNEX_inter[(j - 1)]) {
            current_statement__ = 363;
            assign(mix_is_EX_eta, cons_list(index_uni(i), nil_index_list()),
              which_elem(
                rvalue(mix_idx_eta,
                  cons_list(index_omni(),
                    cons_list(index_uni(j), nil_index_list())),
                  "mix_idx_eta"), 1, pstream__),
              "assigning variable mix_is_EX_eta");
            current_statement__ = 364;
            i = (i + 1);
          } }
      }
      current_statement__ = 204;
      for (int sym1__ = 1; sym1__ <= num_obs; ++sym1__) {
        current_statement__ = 204;
        current_statement__ = 204;
        check_greater_or_equal(function__, "n[sym1__]", n[(sym1__ - 1)], 0);}
      current_statement__ = 207;
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        current_statement__ = 207;
        for (int sym2__ = 1; sym2__ <= num_obs; ++sym2__) {
          current_statement__ = 207;
          current_statement__ = 207;
          check_greater_or_equal(function__, "finite_cov[sym1__, sym2__]",
                                 finite_cov[(sym1__ - 1)][(sym2__ - 1)], 0);}
      }
      current_statement__ = 207;
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        current_statement__ = 207;
        for (int sym2__ = 1; sym2__ <= num_obs; ++sym2__) {
          current_statement__ = 207;
          current_statement__ = 207;
          check_less_or_equal(function__, "finite_cov[sym1__, sym2__]",
                              finite_cov[(sym1__ - 1)][(sym2__ - 1)], 1);}}
      current_statement__ = 208;
      current_statement__ = 208;
      check_greater_or_equal(function__, "num_EXNEX_comp", num_EXNEX_comp, 0);
      current_statement__ = 208;
      current_statement__ = 208;
      check_less_or_equal(function__, "num_EXNEX_comp", num_EXNEX_comp,
                          num_comp);
      current_statement__ = 209;
      current_statement__ = 209;
      check_greater_or_equal(function__, "num_EXNEX_inter", num_EXNEX_inter,
                             0);
      current_statement__ = 209;
      current_statement__ = 209;
      check_less_or_equal(function__, "num_EXNEX_inter", num_EXNEX_inter,
                          num_inter);
      current_statement__ = 210;
      current_statement__ = 210;
      check_greater_or_equal(function__, "num_mix_dim", num_mix_dim, 0);
      current_statement__ = 211;
      current_statement__ = 211;
      check_greater_or_equal(function__, "num_mix_comp", num_mix_comp, 0);
      current_statement__ = 214;
      for (int sym1__ = 1; sym1__ <= num_EXNEX_comp; ++sym1__) {
        current_statement__ = 214;
        for (int sym2__ = 1;
             sym2__ <= (logical_eq(num_mix_dim, 0) ? 0 :
                          power_int(2, (num_mix_dim - 1), pstream__));
             ++sym2__) {
          current_statement__ = 214;
          current_statement__ = 214;
          check_greater_or_equal(function__,
                                 "mix_is_EX_beta[sym1__, sym2__]",
                                 mix_is_EX_beta[(sym1__ - 1)][(sym2__ - 1)],
                                 1);}}
      current_statement__ = 214;
      for (int sym1__ = 1; sym1__ <= num_EXNEX_comp; ++sym1__) {
        current_statement__ = 214;
        for (int sym2__ = 1;
             sym2__ <= (logical_eq(num_mix_dim, 0) ? 0 :
                          power_int(2, (num_mix_dim - 1), pstream__));
             ++sym2__) {
          current_statement__ = 214;
          current_statement__ = 214;
          check_less_or_equal(function__, "mix_is_EX_beta[sym1__, sym2__]",
                              mix_is_EX_beta[(sym1__ - 1)][(sym2__ - 1)],
                              num_mix_comp);}}
      current_statement__ = 217;
      for (int sym1__ = 1; sym1__ <= num_EXNEX_inter; ++sym1__) {
        current_statement__ = 217;
        for (int sym2__ = 1;
             sym2__ <= (logical_eq(num_mix_dim, 0) ? 0 :
                          power_int(2, (num_mix_dim - 1), pstream__));
             ++sym2__) {
          current_statement__ = 217;
          current_statement__ = 217;
          check_greater_or_equal(function__, "mix_is_EX_eta[sym1__, sym2__]",
                                 mix_is_EX_eta[(sym1__ - 1)][(sym2__ - 1)], 1);
        }}
      current_statement__ = 217;
      for (int sym1__ = 1; sym1__ <= num_EXNEX_inter; ++sym1__) {
        current_statement__ = 217;
        for (int sym2__ = 1;
             sym2__ <= (logical_eq(num_mix_dim, 0) ? 0 :
                          power_int(2, (num_mix_dim - 1), pstream__));
             ++sym2__) {
          current_statement__ = 217;
          current_statement__ = 217;
          check_less_or_equal(function__, "mix_is_EX_eta[sym1__, sym2__]",
                              mix_is_EX_eta[(sym1__ - 1)][(sym2__ - 1)],
                              num_mix_comp);}}
      current_statement__ = 220;
      for (int sym1__ = 1; sym1__ <= num_mix_comp; ++sym1__) {
        current_statement__ = 220;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 220;
          current_statement__ = 220;
          check_greater_or_equal(function__, "mix_idx_beta[sym1__, sym2__]",
                                 mix_idx_beta[(sym1__ - 1)][(sym2__ - 1)], 1);
        }}
      current_statement__ = 220;
      for (int sym1__ = 1; sym1__ <= num_mix_comp; ++sym1__) {
        current_statement__ = 220;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 220;
          current_statement__ = 220;
          check_less_or_equal(function__, "mix_idx_beta[sym1__, sym2__]",
                              mix_idx_beta[(sym1__ - 1)][(sym2__ - 1)], 2);}}
      current_statement__ = 223;
      for (int sym1__ = 1; sym1__ <= num_mix_comp; ++sym1__) {
        current_statement__ = 223;
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          current_statement__ = 223;
          current_statement__ = 223;
          check_greater_or_equal(function__, "mix_idx_eta[sym1__, sym2__]",
                                 mix_idx_eta[(sym1__ - 1)][(sym2__ - 1)], 1);
        }}
      current_statement__ = 223;
      for (int sym1__ = 1; sym1__ <= num_mix_comp; ++sym1__) {
        current_statement__ = 223;
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          current_statement__ = 223;
          current_statement__ = 223;
          check_less_or_equal(function__, "mix_idx_eta[sym1__, sym2__]",
                              mix_idx_eta[(sym1__ - 1)][(sym2__ - 1)], 2);}}
      current_statement__ = 225;
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        current_statement__ = 225;
        current_statement__ = 225;
        check_greater_or_equal(function__, "num_obs_group[sym1__]",
                               num_obs_group[(sym1__ - 1)], 0);}
      current_statement__ = 225;
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        current_statement__ = 225;
        current_statement__ = 225;
        check_less_or_equal(function__, "num_obs_group[sym1__]",
                            num_obs_group[(sym1__ - 1)], num_obs);}
      current_statement__ = 227;
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        current_statement__ = 227;
        current_statement__ = 227;
        check_greater_or_equal(function__, "num_cases_group[sym1__]",
                               num_cases_group[(sym1__ - 1)], 0);}
      current_statement__ = 230;
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        current_statement__ = 230;
        for (int sym2__ = 1; sym2__ <= max(num_obs_group); ++sym2__) {
          current_statement__ = 230;
          current_statement__ = 230;
          check_greater_or_equal(function__, "group_obs_idx[sym1__, sym2__]",
                                 group_obs_idx[(sym1__ - 1)][(sym2__ - 1)], 0);
        }}
      current_statement__ = 230;
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        current_statement__ = 230;
        for (int sym2__ = 1; sym2__ <= max(num_obs_group); ++sym2__) {
          current_statement__ = 230;
          current_statement__ = 230;
          check_less_or_equal(function__, "group_obs_idx[sym1__, sym2__]",
                              group_obs_idx[(sym1__ - 1)][(sym2__ - 1)],
                              num_obs);}}
      current_statement__ = 233;
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        current_statement__ = 233;
        for (int sym2__ = 1; sym2__ <= num_mix_comp; ++sym2__) {
          current_statement__ = 233;
          current_statement__ = 233;
          check_less_or_equal(function__, "mix_log_weight[sym1__, sym2__]",
                              mix_log_weight[(sym1__ - 1)][(sym2__ - 1)], 0);
        }}
      current_statement__ = 370;
      log_beta_raw_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 370;
      log_beta_raw_1dim__ = (2 * num_groups);
      current_statement__ = 370;
      validate_non_negative_index("log_beta_raw", "2 * num_groups",
                                  log_beta_raw_1dim__);
      current_statement__ = 371;
      validate_non_negative_index("log_beta_raw", "num_comp", num_comp);
      current_statement__ = 372;
      eta_raw_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 372;
      eta_raw_1dim__ = (2 * num_groups);
      current_statement__ = 372;
      validate_non_negative_index("eta_raw", "2 * num_groups", eta_raw_1dim__);
      current_statement__ = 373;
      validate_non_negative_index("eta_raw", "num_inter", num_inter);
      current_statement__ = 374;
      validate_non_negative_index("mu_log_beta", "num_comp", num_comp);
      current_statement__ = 375;
      validate_non_negative_index("tau_log_beta_raw", "num_strata",
                                  num_strata);
      current_statement__ = 376;
      validate_non_negative_index("tau_log_beta_raw", "num_comp", num_comp);
      current_statement__ = 377;
      validate_non_negative_index("L_corr_log_beta", "num_comp", num_comp);
      current_statement__ = 378;
      validate_non_negative_index("mu_eta", "num_inter", num_inter);
      current_statement__ = 379;
      validate_non_negative_index("tau_eta_raw", "num_strata", num_strata);
      current_statement__ = 380;
      validate_non_negative_index("tau_eta_raw", "num_inter", num_inter);
      current_statement__ = 381;
      validate_non_negative_index("L_corr_eta", "num_inter", num_inter);
      current_statement__ = 381;
      validate_non_negative_index("L_corr_eta", "num_inter", num_inter);
      current_statement__ = 382;
      beta_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 382;
      beta_1dim__ = (2 * num_groups);
      current_statement__ = 382;
      validate_non_negative_index("beta", "2 * num_groups", beta_1dim__);
      current_statement__ = 383;
      validate_non_negative_index("beta", "num_comp", num_comp);
      current_statement__ = 384;
      eta_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 384;
      eta_1dim__ = (2 * num_groups);
      current_statement__ = 384;
      validate_non_negative_index("eta", "2 * num_groups", eta_1dim__);
      current_statement__ = 385;
      validate_non_negative_index("eta", "num_inter", num_inter);
      current_statement__ = 386;
      validate_non_negative_index("tau_log_beta", "num_strata", num_strata);
      current_statement__ = 387;
      validate_non_negative_index("tau_log_beta", "num_comp", num_comp);
      current_statement__ = 388;
      validate_non_negative_index("tau_eta", "num_strata", num_strata);
      current_statement__ = 389;
      validate_non_negative_index("tau_eta", "num_inter", num_inter);
      current_statement__ = 390;
      validate_non_negative_index("beta_EX_prob", "num_groups", num_groups);
      current_statement__ = 391;
      validate_non_negative_index("beta_EX_prob", "num_comp", num_comp);
      current_statement__ = 392;
      validate_non_negative_index("eta_EX_prob", "num_groups", num_groups);
      current_statement__ = 393;
      validate_non_negative_index("eta_EX_prob", "num_inter", num_inter);
      current_statement__ = 394;
      validate_non_negative_index("beta_group", "num_groups", num_groups);
      current_statement__ = 395;
      validate_non_negative_index("beta_group", "num_comp", num_comp);
      current_statement__ = 396;
      validate_non_negative_index("eta_group", "num_groups", num_groups);
      current_statement__ = 397;
      validate_non_negative_index("eta_group", "num_inter", num_inter);
      current_statement__ = 398;
      validate_non_negative_index("log_lik_group", "num_groups", num_groups);
      current_statement__ = 399;
      validate_non_negative_index("rho_log_beta", "num_comp", num_comp);
      current_statement__ = 400;
      validate_non_negative_index("Sigma_corr_eta", "num_inter", num_inter);
      current_statement__ = 401;
      validate_non_negative_index("Sigma_corr_eta", "num_inter", num_inter);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += log_beta_raw_1dim__ * num_comp * 2;
      num_params_r__ += eta_raw_1dim__ * num_inter;
      num_params_r__ += num_comp * 2;
      num_params_r__ += num_strata * num_comp * 2;
      num_params_r__ += num_comp * ((2 * (2 - 1)) / 2);
      num_params_r__ += num_inter;
      num_params_r__ += num_strata * num_inter;
      num_params_r__ += ((num_inter * (num_inter - 1)) / 2);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "model_blrm_exnex_namespace::log_prob";
(void) function__;  // suppress unused var warning
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> log_beta_raw;
      log_beta_raw = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(log_beta_raw_1dim__, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(num_comp, Eigen::Matrix<local_scalar_t__, -1, 1>(2)));
      stan::math::fill(log_beta_raw, DUMMY_VAR__);
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= log_beta_raw_1dim__; ++sym1__) {
        current_statement__ = 1;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 1;
          assign(log_beta_raw,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.vector(2), "assigning variable log_beta_raw");}}
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> eta_raw;
      eta_raw = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(eta_raw_1dim__, Eigen::Matrix<local_scalar_t__, -1, 1>(num_inter));
      stan::math::fill(eta_raw, DUMMY_VAR__);
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= eta_raw_1dim__; ++sym1__) {
        current_statement__ = 2;
        assign(eta_raw, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(num_inter), "assigning variable eta_raw");}
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> mu_log_beta;
      mu_log_beta = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(num_comp, Eigen::Matrix<local_scalar_t__, -1, 1>(2));
      stan::math::fill(mu_log_beta, DUMMY_VAR__);
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        current_statement__ = 3;
        assign(mu_log_beta, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(2), "assigning variable mu_log_beta");}
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> tau_log_beta_raw;
      tau_log_beta_raw = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(num_strata, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(num_comp, Eigen::Matrix<local_scalar_t__, -1, 1>(2)));
      stan::math::fill(tau_log_beta_raw, DUMMY_VAR__);
      
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 4;
          assign(tau_log_beta_raw,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.vector(2), "assigning variable tau_log_beta_raw");}}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 4;
          for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
            current_statement__ = 4;
            if (jacobian__) {
              current_statement__ = 4;
              assign(tau_log_beta_raw,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym3__), nil_index_list()))),
                stan::math::lb_constrain(
                  tau_log_beta_raw[(sym1__ - 1)][(sym2__ - 1)][(sym3__ - 1)],
                  0, lp__), "assigning variable tau_log_beta_raw");
            } else {
              current_statement__ = 4;
              assign(tau_log_beta_raw,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym3__), nil_index_list()))),
                stan::math::lb_constrain(
                  tau_log_beta_raw[(sym1__ - 1)][(sym2__ - 1)][(sym3__ - 1)],
                  0), "assigning variable tau_log_beta_raw");
            }}}}
      std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>> L_corr_log_beta;
      L_corr_log_beta = std::vector<Eigen::Matrix<local_scalar_t__, -1, -1>>(num_comp, Eigen::Matrix<local_scalar_t__, -1, -1>(2, 2));
      stan::math::fill(L_corr_log_beta, DUMMY_VAR__);
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> L_corr_log_beta_in__;
      L_corr_log_beta_in__ = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(num_comp, Eigen::Matrix<local_scalar_t__, -1, 1>(
        ((2 * (2 - 1)) / 2)));
      stan::math::fill(L_corr_log_beta_in__, DUMMY_VAR__);
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        current_statement__ = 5;
        assign(L_corr_log_beta_in__,
          cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(((2 * (2 - 1)) / 2)),
          "assigning variable L_corr_log_beta_in__");}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        current_statement__ = 5;
        if (jacobian__) {
          current_statement__ = 5;
          assign(L_corr_log_beta,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::cholesky_corr_constrain(
              L_corr_log_beta_in__[(sym1__ - 1)], 2, lp__),
            "assigning variable L_corr_log_beta");
        } else {
          current_statement__ = 5;
          assign(L_corr_log_beta,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::cholesky_corr_constrain(
              L_corr_log_beta_in__[(sym1__ - 1)], 2),
            "assigning variable L_corr_log_beta");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> mu_eta;
      mu_eta = Eigen::Matrix<local_scalar_t__, -1, 1>(num_inter);
      stan::math::fill(mu_eta, DUMMY_VAR__);
      
      current_statement__ = 6;
      mu_eta = in__.vector(num_inter);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> tau_eta_raw;
      tau_eta_raw = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(num_strata, Eigen::Matrix<local_scalar_t__, -1, 1>(num_inter));
      stan::math::fill(tau_eta_raw, DUMMY_VAR__);
      
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 7;
        assign(tau_eta_raw, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(num_inter), "assigning variable tau_eta_raw");}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          current_statement__ = 7;
          if (jacobian__) {
            current_statement__ = 7;
            assign(tau_eta_raw,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__), nil_index_list())),
              stan::math::lb_constrain(
                tau_eta_raw[(sym1__ - 1)][(sym2__ - 1)], 0, lp__),
              "assigning variable tau_eta_raw");
          } else {
            current_statement__ = 7;
            assign(tau_eta_raw,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__), nil_index_list())),
              stan::math::lb_constrain(
                tau_eta_raw[(sym1__ - 1)][(sym2__ - 1)], 0),
              "assigning variable tau_eta_raw");
          }}}
      Eigen::Matrix<local_scalar_t__, -1, -1> L_corr_eta;
      L_corr_eta = Eigen::Matrix<local_scalar_t__, -1, -1>(num_inter, num_inter);
      stan::math::fill(L_corr_eta, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> L_corr_eta_in__;
      L_corr_eta_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>(((num_inter *
                                                                  (num_inter
                                                                    - 1)) /
                                                                 2));
      stan::math::fill(L_corr_eta_in__, DUMMY_VAR__);
      
      current_statement__ = 8;
      L_corr_eta_in__ = in__.vector(((num_inter * (num_inter - 1)) / 2));
      current_statement__ = 8;
      if (jacobian__) {
        current_statement__ = 8;
        assign(L_corr_eta, nil_index_list(),
          stan::math::cholesky_corr_constrain(L_corr_eta_in__, num_inter,
            lp__), "assigning variable L_corr_eta");
      } else {
        current_statement__ = 8;
        assign(L_corr_eta, nil_index_list(),
          stan::math::cholesky_corr_constrain(L_corr_eta_in__, num_inter),
          "assigning variable L_corr_eta");
      }
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> beta;
      beta = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(beta_1dim__, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(num_comp, Eigen::Matrix<local_scalar_t__, -1, 1>(2)));
      stan::math::fill(beta, DUMMY_VAR__);
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> eta;
      eta = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(eta_1dim__, Eigen::Matrix<local_scalar_t__, -1, 1>(num_inter));
      stan::math::fill(eta, DUMMY_VAR__);
      
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> tau_log_beta;
      tau_log_beta = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(num_strata, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(num_comp, Eigen::Matrix<local_scalar_t__, -1, 1>(2)));
      stan::math::fill(tau_log_beta, DUMMY_VAR__);
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> tau_eta;
      tau_eta = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(num_strata, Eigen::Matrix<local_scalar_t__, -1, 1>(num_inter));
      stan::math::fill(tau_eta, DUMMY_VAR__);
      
      current_statement__ = 19;
      if (logical_eq(prior_tau_dist, 0)) {
        current_statement__ = 16;
        assign(tau_log_beta, nil_index_list(), prior_EX_tau_mean_comp,
          "assigning variable tau_log_beta");
        current_statement__ = 17;
        assign(tau_eta, nil_index_list(), prior_EX_tau_mean_inter,
          "assigning variable tau_eta");
      } else {
        current_statement__ = 13;
        assign(tau_log_beta, nil_index_list(), tau_log_beta_raw,
          "assigning variable tau_log_beta");
        current_statement__ = 14;
        assign(tau_eta, nil_index_list(), tau_eta_raw,
          "assigning variable tau_eta");
      }
      current_statement__ = 27;
      for (int g = 1; g <= num_groups; ++g) {
        int s;
        s = std::numeric_limits<int>::min();
        
        current_statement__ = 20;
        s = group_stratum_cid[(g - 1)];
        current_statement__ = 23;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 21;
          assign(beta,
            cons_list(index_uni(g),
              cons_list(index_uni(j), nil_index_list())),
            add(mu_log_beta[(j - 1)],
              multiply(
                diag_pre_multiply(tau_log_beta[(s - 1)][(j - 1)],
                  L_corr_log_beta[(j - 1)]), log_beta_raw[(g - 1)][(j - 1)])),
            "assigning variable beta");}
        current_statement__ = 25;
        if (logical_gt(num_inter, 0)) {
          current_statement__ = 24;
          assign(eta, cons_list(index_uni(g), nil_index_list()),
            add(mu_eta,
              multiply(diag_pre_multiply(tau_eta[(s - 1)], L_corr_eta),
                eta_raw[(g - 1)])), "assigning variable eta");
        } }
      current_statement__ = 28;
      assign(beta,
        cons_list(index_min_max((num_groups + 1), (2 * num_groups)),
          nil_index_list()),
        rvalue(log_beta_raw,
          cons_list(index_min_max((num_groups + 1), (2 * num_groups)),
            nil_index_list()), "log_beta_raw"), "assigning variable beta");
      current_statement__ = 29;
      assign(eta,
        cons_list(index_min_max((num_groups + 1), (2 * num_groups)),
          nil_index_list()),
        rvalue(eta_raw,
          cons_list(index_min_max((num_groups + 1), (2 * num_groups)),
            nil_index_list()), "eta_raw"), "assigning variable eta");
      current_statement__ = 32;
      for (int g = 1; g <= (2 * num_groups); ++g) {
        current_statement__ = 31;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 30;
          assign(beta,
            cons_list(index_uni(g),
              cons_list(index_uni(j),
                cons_list(index_uni(2), nil_index_list()))),
            stan::math::exp(beta[(g - 1)][(j - 1)][(2 - 1)]),
            "assigning variable beta");}}
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 11;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 11;
          for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
            current_statement__ = 11;
            current_statement__ = 11;
            check_greater_or_equal(function__,
                                   "tau_log_beta[sym1__, sym2__, sym3__]",
                                   tau_log_beta[(sym1__ - 1)][(sym2__ - 1)][
                                   (sym3__ - 1)], 0);}}}
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 12;
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          current_statement__ = 12;
          current_statement__ = 12;
          check_greater_or_equal(function__, "tau_eta[sym1__, sym2__]",
                                 tau_eta[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      {
        current_statement__ = 113;
        if (logical_negation(prior_PD)) {
          current_statement__ = 111;
          if (logical_eq(num_mix_comp, 1)) {
            current_statement__ = 100;
            validate_non_negative_index("theta", "num_obs", num_obs);
            Eigen::Matrix<local_scalar_t__, -1, 1> theta;
            theta = Eigen::Matrix<local_scalar_t__, -1, 1>(num_obs);
            stan::math::fill(theta, DUMMY_VAR__);
            
            current_statement__ = 108;
            for (int g = 1; g <= num_groups; ++g) {
              int s;
              s = std::numeric_limits<int>::min();
              
              current_statement__ = 102;
              s = group_stratum_cid[(g - 1)];
              int group_size;
              group_size = std::numeric_limits<int>::min();
              
              current_statement__ = 103;
              group_size = num_obs_group[(g - 1)];
              current_statement__ = 104;
              validate_non_negative_index("obs_gidx", "group_size",
                                          group_size);
              std::vector<int> obs_gidx;
              obs_gidx = std::vector<int>(group_size, std::numeric_limits<int>::min());
              
              current_statement__ = 105;
              assign(obs_gidx, nil_index_list(),
                rvalue(group_obs_idx,
                  cons_list(index_uni(g),
                    cons_list(index_min_max(1, group_size), nil_index_list())),
                  "group_obs_idx"), "assigning variable obs_gidx");
              current_statement__ = 106;
              assign(theta,
                cons_list(index_multi(obs_gidx), nil_index_list()),
                blrm_logit_fast(obs_gidx, n, X_comp, finite_cov, X_inter,
                  beta[(g - 1)], eta[(g - 1)], pstream__),
                "assigning variable theta");}
            current_statement__ = 109;
            lp_accum__.add(binomial_logit_lpmf<propto__>(r, n, theta));
          } else {
            current_statement__ = 83;
            validate_non_negative_index("log_lik", "num_groups", num_groups);
            Eigen::Matrix<local_scalar_t__, -1, 1> log_lik;
            log_lik = Eigen::Matrix<local_scalar_t__, -1, 1>(num_groups);
            stan::math::fill(log_lik, DUMMY_VAR__);
            
            current_statement__ = 97;
            for (int g = 1; g <= num_groups; ++g) {
              int s;
              s = std::numeric_limits<int>::min();
              
              current_statement__ = 85;
              s = group_stratum_cid[(g - 1)];
              int group_size;
              group_size = std::numeric_limits<int>::min();
              
              current_statement__ = 86;
              group_size = num_obs_group[(g - 1)];
              current_statement__ = 87;
              validate_non_negative_index("obs_gidx", "group_size",
                                          group_size);
              std::vector<int> obs_gidx;
              obs_gidx = std::vector<int>(group_size, std::numeric_limits<int>::min());
              
              current_statement__ = 88;
              assign(obs_gidx, nil_index_list(),
                rvalue(group_obs_idx,
                  cons_list(index_uni(g),
                    cons_list(index_min_max(1, group_size), nil_index_list())),
                  "group_obs_idx"), "assigning variable obs_gidx");
              current_statement__ = 95;
              if (logical_neq(num_cases_group[(g - 1)], 0)) {
                current_statement__ = 91;
                validate_non_negative_index("mix_ll", "num_mix_comp",
                                            num_mix_comp);
                Eigen::Matrix<local_scalar_t__, -1, 1> mix_ll;
                mix_ll = Eigen::Matrix<local_scalar_t__, -1, 1>(num_mix_comp);
                stan::math::fill(mix_ll, DUMMY_VAR__);
                
                current_statement__ = 92;
                assign(mix_ll, nil_index_list(),
                  add(
                    blrm_mix_lupmf_comp(g, num_groups, obs_gidx, r, n,
                      X_comp, finite_cov, X_inter, beta, mix_idx_beta, eta,
                      mix_idx_eta, pstream__), mix_log_weight[(g - 1)]),
                  "assigning variable mix_ll");
                current_statement__ = 93;
                assign(log_lik, cons_list(index_uni(g), nil_index_list()),
                  log_sum_exp(mix_ll), "assigning variable log_lik");
              } else {
                current_statement__ = 89;
                assign(log_lik, cons_list(index_uni(g), nil_index_list()),
                  0.0, "assigning variable log_lik");
              }}
            current_statement__ = 98;
            lp_accum__.add(sum(log_lik));
          }
        } 
        current_statement__ = 121;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 114;
          lp_accum__.add(
            multi_normal_lpdf<propto__>(mu_log_beta[(j - 1)],
              prior_EX_mu_mean_comp, stan::math::to_matrix(
              std::vector<Eigen::Matrix<double, 1, -1>>{
              (Eigen::Matrix<double,1,-1>(2) <<
              (prior_EX_mu_sd_comp[(j - 1)][(1 - 1)] *
                prior_EX_mu_sd_comp[(j - 1)][(1 - 1)]),
              ((prior_EX_corr_mu_comp *
                 prior_EX_mu_sd_comp[(j - 1)][(1 - 1)]) *
                prior_EX_mu_sd_comp[(j - 1)][(2 - 1)])).finished(),
              (Eigen::Matrix<double,1,-1>(2) <<
              ((prior_EX_corr_mu_comp *
                 prior_EX_mu_sd_comp[(j - 1)][(1 - 1)]) *
                prior_EX_mu_sd_comp[(j - 1)][(2 - 1)]),
              (prior_EX_mu_sd_comp[(j - 1)][(2 - 1)] *
                prior_EX_mu_sd_comp[(j - 1)][(2 - 1)])).finished()})));
          current_statement__ = 118;
          for (int s = 1; s <= num_strata; ++s) {
            current_statement__ = 115;
            lp_accum__.add(
              tau_prior_lpdf<propto__>(
                tau_log_beta_raw[(s - 1)][(j - 1)][(1 - 1)], prior_tau_dist,
                prior_EX_tau_mean_comp[(s - 1)][(j - 1)][(1 - 1)],
                prior_EX_tau_sd_comp[(s - 1)][(j - 1)][(1 - 1)], pstream__));
            current_statement__ = 116;
            lp_accum__.add(
              tau_prior_lpdf<propto__>(
                tau_log_beta_raw[(s - 1)][(j - 1)][(2 - 1)], prior_tau_dist,
                prior_EX_tau_mean_comp[(s - 1)][(j - 1)][(2 - 1)],
                prior_EX_tau_sd_comp[(s - 1)][(j - 1)][(2 - 1)], pstream__));
          }
          current_statement__ = 119;
          lp_accum__.add(
            lkj_corr_cholesky_lpdf<propto__>(L_corr_log_beta[(j - 1)],
              prior_EX_corr_eta_comp[(j - 1)]));}
        current_statement__ = 122;
        lp_accum__.add(
          normal_lpdf<propto__>(mu_eta, prior_EX_mu_mean_inter,
            prior_EX_mu_sd_inter));
        current_statement__ = 125;
        for (int s = 1; s <= num_strata; ++s) {
          current_statement__ = 124;
          for (int j = 1; j <= num_inter; ++j) {
            current_statement__ = 123;
            lp_accum__.add(
              tau_prior_lpdf<propto__>(tau_eta_raw[(s - 1)][(j - 1)],
                prior_tau_dist, prior_EX_tau_mean_inter[(s - 1)][(j - 1)],
                prior_EX_tau_sd_inter[(s - 1)][(j - 1)], pstream__));}}
        current_statement__ = 126;
        lp_accum__.add(
          lkj_corr_cholesky_lpdf<propto__>(L_corr_eta,
            prior_EX_corr_eta_inter));
        current_statement__ = 131;
        for (int g = 1; g <= num_groups; ++g) {
          current_statement__ = 128;
          for (int j = 1; j <= num_comp; ++j) {
            current_statement__ = 127;
            lp_accum__.add(
              std_normal_lpdf<propto__>(log_beta_raw[(g - 1)][(j - 1)]));}
          current_statement__ = 129;
          lp_accum__.add(std_normal_lpdf<propto__>(eta_raw[(g - 1)]));}
        current_statement__ = 137;
        for (int g = (num_groups + 1); g <= (2 * num_groups); ++g) {
          current_statement__ = 134;
          for (int j = 1; j <= num_comp; ++j) {
            current_statement__ = 132;
            lp_accum__.add(
              normal_lpdf<propto__>(log_beta_raw[(g - 1)][(j - 1)],
                prior_NEX_mu_mean_comp[(j - 1)],
                prior_NEX_mu_sd_comp[(j - 1)]));}
          current_statement__ = 135;
          lp_accum__.add(
            normal_lpdf<propto__>(eta_raw[(g - 1)], prior_NEX_mu_mean_inter,
              prior_NEX_mu_sd_inter));}
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "model_blrm_exnex_namespace::write_array";
(void) function__;  // suppress unused var warning
    (void) function__;  // suppress unused var warning
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> log_beta_raw;
      log_beta_raw = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(log_beta_raw_1dim__, std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2)));
      stan::math::fill(log_beta_raw, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= log_beta_raw_1dim__; ++sym1__) {
        current_statement__ = 1;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 1;
          assign(log_beta_raw,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.vector(2), "assigning variable log_beta_raw");}}
      std::vector<Eigen::Matrix<double, -1, 1>> eta_raw;
      eta_raw = std::vector<Eigen::Matrix<double, -1, 1>>(eta_raw_1dim__, Eigen::Matrix<double, -1, 1>(num_inter));
      stan::math::fill(eta_raw, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= eta_raw_1dim__; ++sym1__) {
        current_statement__ = 2;
        assign(eta_raw, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(num_inter), "assigning variable eta_raw");}
      std::vector<Eigen::Matrix<double, -1, 1>> mu_log_beta;
      mu_log_beta = std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2));
      stan::math::fill(mu_log_beta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        current_statement__ = 3;
        assign(mu_log_beta, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(2), "assigning variable mu_log_beta");}
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> tau_log_beta_raw;
      tau_log_beta_raw = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(num_strata, std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2)));
      stan::math::fill(tau_log_beta_raw, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 4;
          assign(tau_log_beta_raw,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            in__.vector(2), "assigning variable tau_log_beta_raw");}}
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 4;
          for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
            current_statement__ = 4;
            assign(tau_log_beta_raw,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              stan::math::lb_constrain(
                tau_log_beta_raw[(sym1__ - 1)][(sym2__ - 1)][(sym3__ - 1)], 0),
              "assigning variable tau_log_beta_raw");}}}
      std::vector<Eigen::Matrix<double, -1, -1>> L_corr_log_beta;
      L_corr_log_beta = std::vector<Eigen::Matrix<double, -1, -1>>(num_comp, Eigen::Matrix<double, -1, -1>(2, 2));
      stan::math::fill(L_corr_log_beta, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> L_corr_log_beta_in__;
      L_corr_log_beta_in__ = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(num_comp, Eigen::Matrix<local_scalar_t__, -1, 1>(
        ((2 * (2 - 1)) / 2)));
      stan::math::fill(L_corr_log_beta_in__, DUMMY_VAR__);
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        current_statement__ = 5;
        assign(L_corr_log_beta_in__,
          cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(((2 * (2 - 1)) / 2)),
          "assigning variable L_corr_log_beta_in__");}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        current_statement__ = 5;
        assign(L_corr_log_beta,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::cholesky_corr_constrain(
            L_corr_log_beta_in__[(sym1__ - 1)], 2),
          "assigning variable L_corr_log_beta");}
      Eigen::Matrix<double, -1, 1> mu_eta;
      mu_eta = Eigen::Matrix<double, -1, 1>(num_inter);
      stan::math::fill(mu_eta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      mu_eta = in__.vector(num_inter);
      std::vector<Eigen::Matrix<double, -1, 1>> tau_eta_raw;
      tau_eta_raw = std::vector<Eigen::Matrix<double, -1, 1>>(num_strata, Eigen::Matrix<double, -1, 1>(num_inter));
      stan::math::fill(tau_eta_raw, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 7;
        assign(tau_eta_raw, cons_list(index_uni(sym1__), nil_index_list()),
          in__.vector(num_inter), "assigning variable tau_eta_raw");}
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          current_statement__ = 7;
          assign(tau_eta_raw,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            stan::math::lb_constrain(tau_eta_raw[(sym1__ - 1)][(sym2__ - 1)],
              0), "assigning variable tau_eta_raw");}}
      Eigen::Matrix<double, -1, -1> L_corr_eta;
      L_corr_eta = Eigen::Matrix<double, -1, -1>(num_inter, num_inter);
      stan::math::fill(L_corr_eta, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<local_scalar_t__, -1, 1> L_corr_eta_in__;
      L_corr_eta_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>(((num_inter *
                                                                  (num_inter
                                                                    - 1)) /
                                                                 2));
      stan::math::fill(L_corr_eta_in__, DUMMY_VAR__);
      
      current_statement__ = 8;
      L_corr_eta_in__ = in__.vector(((num_inter * (num_inter - 1)) / 2));
      current_statement__ = 8;
      assign(L_corr_eta, nil_index_list(),
        stan::math::cholesky_corr_constrain(L_corr_eta_in__, num_inter),
        "assigning variable L_corr_eta");
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> beta;
      beta = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(beta_1dim__, std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2)));
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<Eigen::Matrix<double, -1, 1>> eta;
      eta = std::vector<Eigen::Matrix<double, -1, 1>>(eta_1dim__, Eigen::Matrix<double, -1, 1>(num_inter));
      stan::math::fill(eta, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> tau_log_beta;
      tau_log_beta = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(num_strata, std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2)));
      stan::math::fill(tau_log_beta, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<Eigen::Matrix<double, -1, 1>> tau_eta;
      tau_eta = std::vector<Eigen::Matrix<double, -1, 1>>(num_strata, Eigen::Matrix<double, -1, 1>(num_inter));
      stan::math::fill(tau_eta, std::numeric_limits<double>::quiet_NaN());
      
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= log_beta_raw_1dim__; ++sym3__) {
            vars__.emplace_back(
              log_beta_raw[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= eta_raw_1dim__; ++sym2__) {
          vars__.emplace_back(eta_raw[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          vars__.emplace_back(mu_log_beta[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
            vars__.emplace_back(
              tau_log_beta_raw[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= num_comp; ++sym3__) {
            vars__.emplace_back(
              rvalue(L_corr_log_beta,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                "L_corr_log_beta"));}}}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        vars__.emplace_back(mu_eta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
          vars__.emplace_back(tau_eta_raw[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          vars__.emplace_back(
            rvalue(L_corr_eta,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "L_corr_eta"));}}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 19;
      if (logical_eq(prior_tau_dist, 0)) {
        current_statement__ = 16;
        assign(tau_log_beta, nil_index_list(), prior_EX_tau_mean_comp,
          "assigning variable tau_log_beta");
        current_statement__ = 17;
        assign(tau_eta, nil_index_list(), prior_EX_tau_mean_inter,
          "assigning variable tau_eta");
      } else {
        current_statement__ = 13;
        assign(tau_log_beta, nil_index_list(), tau_log_beta_raw,
          "assigning variable tau_log_beta");
        current_statement__ = 14;
        assign(tau_eta, nil_index_list(), tau_eta_raw,
          "assigning variable tau_eta");
      }
      current_statement__ = 27;
      for (int g = 1; g <= num_groups; ++g) {
        int s;
        s = std::numeric_limits<int>::min();
        
        current_statement__ = 20;
        s = group_stratum_cid[(g - 1)];
        current_statement__ = 23;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 21;
          assign(beta,
            cons_list(index_uni(g),
              cons_list(index_uni(j), nil_index_list())),
            add(mu_log_beta[(j - 1)],
              multiply(
                diag_pre_multiply(tau_log_beta[(s - 1)][(j - 1)],
                  L_corr_log_beta[(j - 1)]), log_beta_raw[(g - 1)][(j - 1)])),
            "assigning variable beta");}
        current_statement__ = 25;
        if (logical_gt(num_inter, 0)) {
          current_statement__ = 24;
          assign(eta, cons_list(index_uni(g), nil_index_list()),
            add(mu_eta,
              multiply(diag_pre_multiply(tau_eta[(s - 1)], L_corr_eta),
                eta_raw[(g - 1)])), "assigning variable eta");
        } }
      current_statement__ = 28;
      assign(beta,
        cons_list(index_min_max((num_groups + 1), (2 * num_groups)),
          nil_index_list()),
        rvalue(log_beta_raw,
          cons_list(index_min_max((num_groups + 1), (2 * num_groups)),
            nil_index_list()), "log_beta_raw"), "assigning variable beta");
      current_statement__ = 29;
      assign(eta,
        cons_list(index_min_max((num_groups + 1), (2 * num_groups)),
          nil_index_list()),
        rvalue(eta_raw,
          cons_list(index_min_max((num_groups + 1), (2 * num_groups)),
            nil_index_list()), "eta_raw"), "assigning variable eta");
      current_statement__ = 32;
      for (int g = 1; g <= (2 * num_groups); ++g) {
        current_statement__ = 31;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 30;
          assign(beta,
            cons_list(index_uni(g),
              cons_list(index_uni(j),
                cons_list(index_uni(2), nil_index_list()))),
            stan::math::exp(beta[(g - 1)][(j - 1)][(2 - 1)]),
            "assigning variable beta");}}
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 11;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 11;
          for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
            current_statement__ = 11;
            current_statement__ = 11;
            check_greater_or_equal(function__,
                                   "tau_log_beta[sym1__, sym2__, sym3__]",
                                   tau_log_beta[(sym1__ - 1)][(sym2__ - 1)][
                                   (sym3__ - 1)], 0);}}}
      current_statement__ = 12;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 12;
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          current_statement__ = 12;
          current_statement__ = 12;
          check_greater_or_equal(function__, "tau_eta[sym1__, sym2__]",
                                 tau_eta[(sym1__ - 1)][(sym2__ - 1)], 0);}}
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= beta_1dim__; ++sym3__) {
              vars__.emplace_back(
                beta[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= eta_1dim__; ++sym2__) {
            vars__.emplace_back(eta[(sym2__ - 1)][(sym1__ - 1)]);}}
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
              vars__.emplace_back(
                tau_log_beta[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
            vars__.emplace_back(tau_eta[(sym2__ - 1)][(sym1__ - 1)]);}}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      Eigen::Matrix<double, -1, -1> beta_EX_prob;
      beta_EX_prob = Eigen::Matrix<double, -1, -1>(num_groups, num_comp);
      stan::math::fill(beta_EX_prob, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> eta_EX_prob;
      eta_EX_prob = Eigen::Matrix<double, -1, -1>(num_groups, num_inter);
      stan::math::fill(eta_EX_prob, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> beta_group;
      beta_group = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(num_groups, std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2)));
      stan::math::fill(beta_group, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<Eigen::Matrix<double, -1, 1>> eta_group;
      eta_group = std::vector<Eigen::Matrix<double, -1, 1>>(num_groups, Eigen::Matrix<double, -1, 1>(num_inter));
      stan::math::fill(eta_group, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> log_lik_group;
      log_lik_group = Eigen::Matrix<double, -1, 1>(num_groups);
      stan::math::fill(log_lik_group, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> rho_log_beta;
      rho_log_beta = Eigen::Matrix<double, -1, 1>(num_comp);
      stan::math::fill(rho_log_beta, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> Sigma_corr_eta;
      Sigma_corr_eta = Eigen::Matrix<double, -1, -1>(num_inter, num_inter);
      stan::math::fill(Sigma_corr_eta, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 39;
      assign(Sigma_corr_eta, nil_index_list(),
        multiply_lower_tri_self_transpose(L_corr_eta),
        "assigning variable Sigma_corr_eta");
      current_statement__ = 43;
      for (int j = 1; j <= num_comp; ++j) {
        Eigen::Matrix<double, -1, -1> Sigma_corr_log_beta;
        Sigma_corr_log_beta = Eigen::Matrix<double, -1, -1>(2, 2);
        stan::math::fill(Sigma_corr_log_beta, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 40;
        assign(Sigma_corr_log_beta, nil_index_list(),
          multiply_lower_tri_self_transpose(L_corr_log_beta[(j - 1)]),
          "assigning variable Sigma_corr_log_beta");
        current_statement__ = 41;
        assign(rho_log_beta, cons_list(index_uni(j), nil_index_list()),
          rvalue(Sigma_corr_log_beta,
            cons_list(index_uni(2),
              cons_list(index_uni(1), nil_index_list())),
            "Sigma_corr_log_beta"), "assigning variable rho_log_beta");}
      current_statement__ = 82;
      for (int g = 1; g <= num_groups; ++g) {
        int s;
        s = std::numeric_limits<int>::min();
        
        current_statement__ = 44;
        s = group_stratum_cid[(g - 1)];
        int group_size;
        group_size = std::numeric_limits<int>::min();
        
        current_statement__ = 45;
        group_size = num_obs_group[(g - 1)];
        current_statement__ = 46;
        validate_non_negative_index("obs_gidx", "group_size", group_size);
        std::vector<int> obs_gidx;
        obs_gidx = std::vector<int>(group_size, std::numeric_limits<int>::min());
        
        current_statement__ = 47;
        assign(obs_gidx, nil_index_list(),
          rvalue(group_obs_idx,
            cons_list(index_uni(g),
              cons_list(index_min_max(1, group_size), nil_index_list())),
            "group_obs_idx"), "assigning variable obs_gidx");
        current_statement__ = 48;
        validate_non_negative_index("mix_ll", "num_mix_comp", num_mix_comp);
        Eigen::Matrix<double, -1, 1> mix_ll;
        mix_ll = Eigen::Matrix<double, -1, 1>(num_mix_comp);
        stan::math::fill(mix_ll, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 49;
        assign(mix_ll, nil_index_list(),
          add(
            blrm_mix_lupmf_comp(g, num_groups, obs_gidx, r, n, X_comp,
              finite_cov, X_inter, beta, mix_idx_beta, eta,
              mix_idx_eta, pstream__), mix_log_weight[(g - 1)]),
          "assigning variable mix_ll");
        double log_norm;
        log_norm = std::numeric_limits<double>::quiet_NaN();
        
        current_statement__ = 50;
        log_norm = log_sum_exp(mix_ll);
        current_statement__ = 51;
        validate_non_negative_index("log_EX_prob_mix", "num_mix_comp",
                                    num_mix_comp);
        Eigen::Matrix<double, -1, 1> log_EX_prob_mix;
        log_EX_prob_mix = Eigen::Matrix<double, -1, 1>(num_mix_comp);
        stan::math::fill(log_EX_prob_mix, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 52;
        assign(log_EX_prob_mix, nil_index_list(), subtract(mix_ll, log_norm),
          "assigning variable log_EX_prob_mix");
        int mix_config_ind;
        mix_config_ind = std::numeric_limits<int>::min();
        
        current_statement__ = 53;
        mix_config_ind = categorical_rng(stan::math::exp(log_EX_prob_mix),
                           base_rng__);
        current_statement__ = 54;
        validate_non_negative_index("mix_beta_config", "num_comp", num_comp);
        std::vector<int> mix_beta_config;
        mix_beta_config = std::vector<int>(num_comp, std::numeric_limits<int>::min());
        
        current_statement__ = 55;
        assign(mix_beta_config, nil_index_list(),
          mix_idx_beta[(mix_config_ind - 1)],
          "assigning variable mix_beta_config");
        current_statement__ = 56;
        validate_non_negative_index("mix_eta_config", "num_inter", num_inter);
        std::vector<int> mix_eta_config;
        mix_eta_config = std::vector<int>(num_inter, std::numeric_limits<int>::min());
        
        current_statement__ = 57;
        assign(mix_eta_config, nil_index_list(),
          mix_idx_eta[(mix_config_ind - 1)],
          "assigning variable mix_eta_config");
        current_statement__ = 58;
        assign(log_lik_group, cons_list(index_uni(g), nil_index_list()),
          (log_norm + log_normfactor_group[(g - 1)]),
          "assigning variable log_lik_group");
        {
          int i;
          i = std::numeric_limits<int>::min();
          
          current_statement__ = 59;
          i = 1;
          current_statement__ = 68;
          for (int j = 1; j <= num_comp; ++j) {
            current_statement__ = 65;
            if (prior_is_EXNEX_comp[(j - 1)]) {
              current_statement__ = 62;
              assign(beta_EX_prob,
                cons_list(index_uni(g),
                  cons_list(index_uni(j), nil_index_list())),
                stan::math::exp(
                  log_sum_exp(
                    rvalue(log_EX_prob_mix,
                      cons_list(index_multi(mix_is_EX_beta[(i - 1)]),
                        nil_index_list()), "log_EX_prob_mix"))),
                "assigning variable beta_EX_prob");
              current_statement__ = 63;
              i = (i + 1);
            } else {
              current_statement__ = 60;
              assign(beta_EX_prob,
                cons_list(index_uni(g),
                  cons_list(index_uni(j), nil_index_list())), 1.0,
                "assigning variable beta_EX_prob");
            }
            current_statement__ = 66;
            assign(beta_group,
              cons_list(index_uni(g),
                cons_list(index_uni(j), nil_index_list())),
              beta[((g +
                      (logical_eq(mix_beta_config[(j - 1)], 1) ? 0 :
                         num_groups)) - 1)][(j - 1)],
              "assigning variable beta_group");}
        }
        {
          int i;
          i = std::numeric_limits<int>::min();
          
          current_statement__ = 70;
          i = 1;
          current_statement__ = 79;
          for (int j = 1; j <= num_inter; ++j) {
            current_statement__ = 76;
            if (prior_is_EXNEX_inter[(j - 1)]) {
              current_statement__ = 73;
              assign(eta_EX_prob,
                cons_list(index_uni(g),
                  cons_list(index_uni(j), nil_index_list())),
                stan::math::exp(
                  log_sum_exp(
                    rvalue(log_EX_prob_mix,
                      cons_list(index_multi(mix_is_EX_eta[(i - 1)]),
                        nil_index_list()), "log_EX_prob_mix"))),
                "assigning variable eta_EX_prob");
              current_statement__ = 74;
              i = (i + 1);
            } else {
              current_statement__ = 71;
              assign(eta_EX_prob,
                cons_list(index_uni(g),
                  cons_list(index_uni(j), nil_index_list())), 1.0,
                "assigning variable eta_EX_prob");
            }
            current_statement__ = 77;
            assign(eta_group,
              cons_list(index_uni(g),
                cons_list(index_uni(j), nil_index_list())),
              eta[((g +
                     (logical_eq(mix_eta_config[(j - 1)], 1) ? 0 : num_groups))
                    - 1)][(j - 1)], "assigning variable eta_group");}
        }}
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
          vars__.emplace_back(
            rvalue(beta_EX_prob,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "beta_EX_prob"));}}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
          vars__.emplace_back(
            rvalue(eta_EX_prob,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "eta_EX_prob"));}}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= num_groups; ++sym3__) {
            vars__.emplace_back(
              beta_group[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}}}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
          vars__.emplace_back(eta_group[(sym2__ - 1)][(sym1__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        vars__.emplace_back(log_lik_group[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        vars__.emplace_back(rho_log_beta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          vars__.emplace_back(
            rvalue(Sigma_corr_eta,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "Sigma_corr_eta"));}}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> log_beta_raw;
      log_beta_raw = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(log_beta_raw_1dim__, std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2)));
      stan::math::fill(log_beta_raw, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> log_beta_raw_flat__;
        current_statement__ = 1;
        assign(log_beta_raw_flat__, nil_index_list(),
          context__.vals_r("log_beta_raw"),
          "assigning variable log_beta_raw_flat__");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 1;
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            current_statement__ = 1;
            for (int sym3__ = 1; sym3__ <= log_beta_raw_1dim__; ++sym3__) {
              current_statement__ = 1;
              assign(log_beta_raw,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                log_beta_raw_flat__[(pos__ - 1)],
                "assigning variable log_beta_raw");
              current_statement__ = 1;
              pos__ = (pos__ + 1);}}}
      }
      std::vector<Eigen::Matrix<double, -1, 1>> eta_raw;
      eta_raw = std::vector<Eigen::Matrix<double, -1, 1>>(eta_raw_1dim__, Eigen::Matrix<double, -1, 1>(num_inter));
      stan::math::fill(eta_raw, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> eta_raw_flat__;
        current_statement__ = 2;
        assign(eta_raw_flat__, nil_index_list(), context__.vals_r("eta_raw"),
          "assigning variable eta_raw_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 2;
          for (int sym2__ = 1; sym2__ <= eta_raw_1dim__; ++sym2__) {
            current_statement__ = 2;
            assign(eta_raw,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              eta_raw_flat__[(pos__ - 1)], "assigning variable eta_raw");
            current_statement__ = 2;
            pos__ = (pos__ + 1);}}
      }
      std::vector<Eigen::Matrix<double, -1, 1>> mu_log_beta;
      mu_log_beta = std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2));
      stan::math::fill(mu_log_beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> mu_log_beta_flat__;
        current_statement__ = 3;
        assign(mu_log_beta_flat__, nil_index_list(),
          context__.vals_r("mu_log_beta"),
          "assigning variable mu_log_beta_flat__");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 3;
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            current_statement__ = 3;
            assign(mu_log_beta,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              mu_log_beta_flat__[(pos__ - 1)],
              "assigning variable mu_log_beta");
            current_statement__ = 3;
            pos__ = (pos__ + 1);}}
      }
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> tau_log_beta_raw;
      tau_log_beta_raw = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(num_strata, std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2)));
      stan::math::fill(tau_log_beta_raw, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> tau_log_beta_raw_flat__;
        current_statement__ = 4;
        assign(tau_log_beta_raw_flat__, nil_index_list(),
          context__.vals_r("tau_log_beta_raw"),
          "assigning variable tau_log_beta_raw_flat__");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 4;
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            current_statement__ = 4;
            for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
              current_statement__ = 4;
              assign(tau_log_beta_raw,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                tau_log_beta_raw_flat__[(pos__ - 1)],
                "assigning variable tau_log_beta_raw");
              current_statement__ = 4;
              pos__ = (pos__ + 1);}}}
      }
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> tau_log_beta_raw_free__;
      tau_log_beta_raw_free__ = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(num_strata, std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(2)));
      stan::math::fill(tau_log_beta_raw_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 4;
          for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
            current_statement__ = 4;
            assign(tau_log_beta_raw_free__,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym3__), nil_index_list()))),
              stan::math::lb_free(
                tau_log_beta_raw[(sym1__ - 1)][(sym2__ - 1)][(sym3__ - 1)], 0),
              "assigning variable tau_log_beta_raw_free__");}}}
      std::vector<Eigen::Matrix<double, -1, -1>> L_corr_log_beta;
      L_corr_log_beta = std::vector<Eigen::Matrix<double, -1, -1>>(num_comp, Eigen::Matrix<double, -1, -1>(2, 2));
      stan::math::fill(L_corr_log_beta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> L_corr_log_beta_flat__;
        current_statement__ = 5;
        assign(L_corr_log_beta_flat__, nil_index_list(),
          context__.vals_r("L_corr_log_beta"),
          "assigning variable L_corr_log_beta_flat__");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 5;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 5;
            for (int sym3__ = 1; sym3__ <= num_comp; ++sym3__) {
              current_statement__ = 5;
              assign(L_corr_log_beta,
                cons_list(index_uni(sym3__),
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list()))),
                L_corr_log_beta_flat__[(pos__ - 1)],
                "assigning variable L_corr_log_beta");
              current_statement__ = 5;
              pos__ = (pos__ + 1);}}}
      }
      std::vector<Eigen::Matrix<double, -1, 1>> L_corr_log_beta_free__;
      L_corr_log_beta_free__ = std::vector<Eigen::Matrix<double, -1, 1>>(num_comp, Eigen::Matrix<double, -1, 1>(
        ((2 * (2 - 1)) / 2)));
      stan::math::fill(L_corr_log_beta_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        current_statement__ = 5;
        assign(L_corr_log_beta_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::cholesky_corr_free(L_corr_log_beta[(sym1__ - 1)]),
          "assigning variable L_corr_log_beta_free__");}
      Eigen::Matrix<double, -1, 1> mu_eta;
      mu_eta = Eigen::Matrix<double, -1, 1>(num_inter);
      stan::math::fill(mu_eta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> mu_eta_flat__;
        current_statement__ = 6;
        assign(mu_eta_flat__, nil_index_list(), context__.vals_r("mu_eta"),
          "assigning variable mu_eta_flat__");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 6;
          assign(mu_eta, cons_list(index_uni(sym1__), nil_index_list()),
            mu_eta_flat__[(pos__ - 1)], "assigning variable mu_eta");
          current_statement__ = 6;
          pos__ = (pos__ + 1);}
      }
      std::vector<Eigen::Matrix<double, -1, 1>> tau_eta_raw;
      tau_eta_raw = std::vector<Eigen::Matrix<double, -1, 1>>(num_strata, Eigen::Matrix<double, -1, 1>(num_inter));
      stan::math::fill(tau_eta_raw, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> tau_eta_raw_flat__;
        current_statement__ = 7;
        assign(tau_eta_raw_flat__, nil_index_list(),
          context__.vals_r("tau_eta_raw"),
          "assigning variable tau_eta_raw_flat__");
        current_statement__ = 7;
        pos__ = 1;
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 7;
          for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
            current_statement__ = 7;
            assign(tau_eta_raw,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              tau_eta_raw_flat__[(pos__ - 1)],
              "assigning variable tau_eta_raw");
            current_statement__ = 7;
            pos__ = (pos__ + 1);}}
      }
      std::vector<Eigen::Matrix<double, -1, 1>> tau_eta_raw_free__;
      tau_eta_raw_free__ = std::vector<Eigen::Matrix<double, -1, 1>>(num_strata, Eigen::Matrix<double, -1, 1>(num_inter));
      stan::math::fill(tau_eta_raw_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          current_statement__ = 7;
          assign(tau_eta_raw_free__,
            cons_list(index_uni(sym1__),
              cons_list(index_uni(sym2__), nil_index_list())),
            stan::math::lb_free(tau_eta_raw[(sym1__ - 1)][(sym2__ - 1)], 0),
            "assigning variable tau_eta_raw_free__");}}
      Eigen::Matrix<double, -1, -1> L_corr_eta;
      L_corr_eta = Eigen::Matrix<double, -1, -1>(num_inter, num_inter);
      stan::math::fill(L_corr_eta, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> L_corr_eta_flat__;
        current_statement__ = 8;
        assign(L_corr_eta_flat__, nil_index_list(),
          context__.vals_r("L_corr_eta"),
          "assigning variable L_corr_eta_flat__");
        current_statement__ = 8;
        pos__ = 1;
        current_statement__ = 8;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 8;
          for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
            current_statement__ = 8;
            assign(L_corr_eta,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              L_corr_eta_flat__[(pos__ - 1)], "assigning variable L_corr_eta");
            current_statement__ = 8;
            pos__ = (pos__ + 1);}}
      }
      Eigen::Matrix<double, -1, 1> L_corr_eta_free__;
      L_corr_eta_free__ = Eigen::Matrix<double, -1, 1>(((num_inter *
                                                          (num_inter - 1)) /
                                                         2));
      stan::math::fill(L_corr_eta_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      assign(L_corr_eta_free__, nil_index_list(),
        stan::math::cholesky_corr_free(L_corr_eta),
        "assigning variable L_corr_eta_free__");
      for (int sym1__ = 1; sym1__ <= log_beta_raw_1dim__; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
            vars__.emplace_back(
              log_beta_raw[(sym1__ - 1)][(sym2__ - 1)][(sym3__ - 1)]);}}}
      for (int sym1__ = 1; sym1__ <= eta_raw_1dim__; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          vars__.emplace_back(eta_raw[(sym1__ - 1)][(sym2__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          vars__.emplace_back(mu_log_beta[(sym1__ - 1)][(sym2__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= 2; ++sym3__) {
            vars__.emplace_back(
              tau_log_beta_raw_free__[(sym1__ - 1)][(sym2__ - 1)][(sym3__ -
                                                                    1)]);}}}
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= ((2 * (2 - 1)) / 2); ++sym2__) {
          vars__.emplace_back(
            L_corr_log_beta_free__[(sym1__ - 1)][(sym2__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        vars__.emplace_back(mu_eta[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= num_strata; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          vars__.emplace_back(
            tau_eta_raw_free__[(sym1__ - 1)][(sym2__ - 1)]);}}
      for (int sym1__ = 1; sym1__ <= ((num_inter * (num_inter - 1)) / 2);
           ++sym1__) { vars__.emplace_back(L_corr_eta_free__[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("log_beta_raw");
    names__.emplace_back("eta_raw");
    names__.emplace_back("mu_log_beta");
    names__.emplace_back("tau_log_beta_raw");
    names__.emplace_back("L_corr_log_beta");
    names__.emplace_back("mu_eta");
    names__.emplace_back("tau_eta_raw");
    names__.emplace_back("L_corr_eta");
    names__.emplace_back("beta");
    names__.emplace_back("eta");
    names__.emplace_back("tau_log_beta");
    names__.emplace_back("tau_eta");
    names__.emplace_back("beta_EX_prob");
    names__.emplace_back("eta_EX_prob");
    names__.emplace_back("beta_group");
    names__.emplace_back("eta_group");
    names__.emplace_back("log_lik_group");
    names__.emplace_back("rho_log_beta");
    names__.emplace_back("Sigma_corr_eta");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(log_beta_raw_1dim__)
                                             , static_cast<size_t>(num_comp),
                                             static_cast<size_t>(2)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(eta_raw_1dim__)
                                             , static_cast<size_t>(num_inter)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(num_comp),
                                             static_cast<size_t>(2)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(num_strata),
                                             static_cast<size_t>(num_comp),
                                             static_cast<size_t>(2)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(num_comp),
                                             static_cast<size_t>(2),
                                             static_cast<size_t>(2)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(num_inter)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(num_strata),
                                             static_cast<size_t>(num_inter)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(num_inter),
                                             static_cast<size_t>(num_inter)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(beta_1dim__)
                                             , static_cast<size_t>(num_comp),
                                             static_cast<size_t>(2)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(eta_1dim__),
                                             static_cast<size_t>(num_inter)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(num_strata),
                                             static_cast<size_t>(num_comp),
                                             static_cast<size_t>(2)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(num_strata),
                                             static_cast<size_t>(num_inter)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(num_groups),
                                             static_cast<size_t>(num_comp)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(num_groups),
                                             static_cast<size_t>(num_inter)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(num_groups),
                                             static_cast<size_t>(num_comp),
                                             static_cast<size_t>(2)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(num_groups),
                                             static_cast<size_t>(num_inter)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(num_groups)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(num_comp)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(num_inter),
                                             static_cast<size_t>(num_inter)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= log_beta_raw_1dim__; ++sym3__) {
              {
                param_names__.emplace_back(std::string() + "log_beta_raw" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= eta_raw_1dim__; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "eta_raw" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "mu_log_beta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
              {
                param_names__.emplace_back(std::string() + "tau_log_beta_raw" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= num_comp; ++sym3__) {
              {
                param_names__.emplace_back(std::string() + "L_corr_log_beta" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "mu_eta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "tau_eta_raw" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "L_corr_eta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= beta_1dim__; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= eta_1dim__; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "eta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "tau_log_beta" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "tau_eta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "beta_EX_prob" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "eta_EX_prob" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= num_groups; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "beta_group" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "eta_group" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik_group" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "rho_log_beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "Sigma_corr_eta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= log_beta_raw_1dim__; ++sym3__) {
              {
                param_names__.emplace_back(std::string() + "log_beta_raw" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= eta_raw_1dim__; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "eta_raw" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "mu_log_beta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          {
            for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
              {
                param_names__.emplace_back(std::string() + "tau_log_beta_raw" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
              }}
          }}
      }}
    for (int sym1__ = 1; sym1__ <= ((2 * (2 - 1)) / 2); ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "L_corr_log_beta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "mu_eta" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "tau_eta_raw" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    for (int sym1__ = 1; sym1__ <= ((num_inter * (num_inter - 1)) / 2);
         ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "L_corr_eta" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= beta_1dim__; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= eta_1dim__; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "eta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "tau_log_beta" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "tau_eta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "beta_EX_prob" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "eta_EX_prob" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            {
              for (int sym3__ = 1; sym3__ <= num_groups; ++sym3__) {
                {
                  param_names__.emplace_back(std::string() + "beta_group" + '.' + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
                }}
            }}
        }}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "eta_group" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik_group" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "rho_log_beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "Sigma_corr_eta" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"log_beta_raw\",\"type\":{\"name\":\"array\",\"length\":" << log_beta_raw_1dim__ << ",\"element_type\":{\"name\":\"array\",\"length\":" << num_comp << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 2 << "}}},\"block\":\"parameters\"},{\"name\":\"eta_raw\",\"type\":{\"name\":\"array\",\"length\":" << eta_raw_1dim__ << ",\"element_type\":{\"name\":\"vector\",\"length\":" << num_inter << "}},\"block\":\"parameters\"},{\"name\":\"mu_log_beta\",\"type\":{\"name\":\"array\",\"length\":" << num_comp << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 2 << "}},\"block\":\"parameters\"},{\"name\":\"tau_log_beta_raw\",\"type\":{\"name\":\"array\",\"length\":" << num_strata << ",\"element_type\":{\"name\":\"array\",\"length\":" << num_comp << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 2 << "}}},\"block\":\"parameters\"},{\"name\":\"L_corr_log_beta\",\"type\":{\"name\":\"array\",\"length\":" << num_comp << ",\"element_type\":{\"name\":\"matrix\",\"rows\":" << 2 << ",\"cols\":" << 2 << "}},\"block\":\"parameters\"},{\"name\":\"mu_eta\",\"type\":{\"name\":\"vector\",\"length\":" << num_inter << "},\"block\":\"parameters\"},{\"name\":\"tau_eta_raw\",\"type\":{\"name\":\"array\",\"length\":" << num_strata << ",\"element_type\":{\"name\":\"vector\",\"length\":" << num_inter << "}},\"block\":\"parameters\"},{\"name\":\"L_corr_eta\",\"type\":{\"name\":\"matrix\",\"rows\":" << num_inter << ",\"cols\":" << num_inter << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"array\",\"length\":" << beta_1dim__ << ",\"element_type\":{\"name\":\"array\",\"length\":" << num_comp << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 2 << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"eta\",\"type\":{\"name\":\"array\",\"length\":" << eta_1dim__ << ",\"element_type\":{\"name\":\"vector\",\"length\":" << num_inter << "}},\"block\":\"transformed_parameters\"},{\"name\":\"tau_log_beta\",\"type\":{\"name\":\"array\",\"length\":" << num_strata << ",\"element_type\":{\"name\":\"array\",\"length\":" << num_comp << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 2 << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"tau_eta\",\"type\":{\"name\":\"array\",\"length\":" << num_strata << ",\"element_type\":{\"name\":\"vector\",\"length\":" << num_inter << "}},\"block\":\"transformed_parameters\"},{\"name\":\"beta_EX_prob\",\"type\":{\"name\":\"matrix\",\"rows\":" << num_groups << ",\"cols\":" << num_comp << "},\"block\":\"generated_quantities\"},{\"name\":\"eta_EX_prob\",\"type\":{\"name\":\"matrix\",\"rows\":" << num_groups << ",\"cols\":" << num_inter << "},\"block\":\"generated_quantities\"},{\"name\":\"beta_group\",\"type\":{\"name\":\"array\",\"length\":" << num_groups << ",\"element_type\":{\"name\":\"array\",\"length\":" << num_comp << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 2 << "}}},\"block\":\"generated_quantities\"},{\"name\":\"eta_group\",\"type\":{\"name\":\"array\",\"length\":" << num_groups << ",\"element_type\":{\"name\":\"vector\",\"length\":" << num_inter << "}},\"block\":\"generated_quantities\"},{\"name\":\"log_lik_group\",\"type\":{\"name\":\"vector\",\"length\":" << num_groups << "},\"block\":\"generated_quantities\"},{\"name\":\"rho_log_beta\",\"type\":{\"name\":\"vector\",\"length\":" << num_comp << "},\"block\":\"generated_quantities\"},{\"name\":\"Sigma_corr_eta\",\"type\":{\"name\":\"matrix\",\"rows\":" << num_inter << ",\"cols\":" << num_inter << "},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"log_beta_raw\",\"type\":{\"name\":\"array\",\"length\":" << log_beta_raw_1dim__ << ",\"element_type\":{\"name\":\"array\",\"length\":" << num_comp << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 2 << "}}},\"block\":\"parameters\"},{\"name\":\"eta_raw\",\"type\":{\"name\":\"array\",\"length\":" << eta_raw_1dim__ << ",\"element_type\":{\"name\":\"vector\",\"length\":" << num_inter << "}},\"block\":\"parameters\"},{\"name\":\"mu_log_beta\",\"type\":{\"name\":\"array\",\"length\":" << num_comp << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 2 << "}},\"block\":\"parameters\"},{\"name\":\"tau_log_beta_raw\",\"type\":{\"name\":\"array\",\"length\":" << num_strata << ",\"element_type\":{\"name\":\"array\",\"length\":" << num_comp << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 2 << "}}},\"block\":\"parameters\"},{\"name\":\"L_corr_log_beta\",\"type\":{\"name\":\"array\",\"length\":" << num_comp << ",\"element_type\":{\"name\":\"vector\",\"length\":" << ((2 * (2 - 1)) / 2) << "}},\"block\":\"parameters\"},{\"name\":\"mu_eta\",\"type\":{\"name\":\"vector\",\"length\":" << num_inter << "},\"block\":\"parameters\"},{\"name\":\"tau_eta_raw\",\"type\":{\"name\":\"array\",\"length\":" << num_strata << ",\"element_type\":{\"name\":\"vector\",\"length\":" << num_inter << "}},\"block\":\"parameters\"},{\"name\":\"L_corr_eta\",\"type\":{\"name\":\"vector\",\"length\":" << ((num_inter * (num_inter - 1)) / 2) << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"array\",\"length\":" << beta_1dim__ << ",\"element_type\":{\"name\":\"array\",\"length\":" << num_comp << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 2 << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"eta\",\"type\":{\"name\":\"array\",\"length\":" << eta_1dim__ << ",\"element_type\":{\"name\":\"vector\",\"length\":" << num_inter << "}},\"block\":\"transformed_parameters\"},{\"name\":\"tau_log_beta\",\"type\":{\"name\":\"array\",\"length\":" << num_strata << ",\"element_type\":{\"name\":\"array\",\"length\":" << num_comp << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 2 << "}}},\"block\":\"transformed_parameters\"},{\"name\":\"tau_eta\",\"type\":{\"name\":\"array\",\"length\":" << num_strata << ",\"element_type\":{\"name\":\"vector\",\"length\":" << num_inter << "}},\"block\":\"transformed_parameters\"},{\"name\":\"beta_EX_prob\",\"type\":{\"name\":\"matrix\",\"rows\":" << num_groups << ",\"cols\":" << num_comp << "},\"block\":\"generated_quantities\"},{\"name\":\"eta_EX_prob\",\"type\":{\"name\":\"matrix\",\"rows\":" << num_groups << ",\"cols\":" << num_inter << "},\"block\":\"generated_quantities\"},{\"name\":\"beta_group\",\"type\":{\"name\":\"array\",\"length\":" << num_groups << ",\"element_type\":{\"name\":\"array\",\"length\":" << num_comp << ",\"element_type\":{\"name\":\"vector\",\"length\":" << 2 << "}}},\"block\":\"generated_quantities\"},{\"name\":\"eta_group\",\"type\":{\"name\":\"array\",\"length\":" << num_groups << ",\"element_type\":{\"name\":\"vector\",\"length\":" << num_inter << "}},\"block\":\"generated_quantities\"},{\"name\":\"log_lik_group\",\"type\":{\"name\":\"vector\",\"length\":" << num_groups << "},\"block\":\"generated_quantities\"},{\"name\":\"rho_log_beta\",\"type\":{\"name\":\"vector\",\"length\":" << num_comp << "},\"block\":\"generated_quantities\"},{\"name\":\"Sigma_corr_eta\",\"type\":{\"name\":\"matrix\",\"rows\":" << num_inter << ",\"cols\":" << num_inter << "},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }
    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }
    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  
    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        
};
}
using stan_model = model_blrm_exnex_namespace::model_blrm_exnex;
#ifndef USING_R
// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_blrm_exnex_namespace::profiles__;
}
#endif
#endif
